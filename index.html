<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="theme-color" content="#007bff">
    <meta name="description" content="Build and evaluate logical arguments with formal validity checking">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="/manifest.json">
    
    <!-- iOS Icons -->
    <link rel="apple-touch-icon" href="/icons/icon-152x152.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/icons/icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/icons/icon-180x180.png">
    <link rel="apple-touch-icon" sizes="167x167" href="/icons/icon-167x167.png">
    
    <!-- Splash Screens for iOS -->
    <link rel="apple-touch-startup-image" href="/splash/launch-640x1136.png" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2)">
    <link rel="apple-touch-startup-image" href="/splash/launch-750x1334.png" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2)">
    <link rel="apple-touch-startup-image" href="/splash/launch-1242x2208.png" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3)">
    
    <title>Crux</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" />
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Enhanced Modern Design System - Add this to your existing styles or replace the <style> section */
:root {
    --primary: #667eea;
    --primary-dark: #5a67d8;
    --primary-light: #7c8ff5;
    --secondary: #48bb78;
    --danger: #f56565;
    --warning: #ed8936;
    --info: #4299e1;
    --dark: #1a1a2e;
    --dark-lighter: #16213e;
    --gray-100: #f7fafc;
    --gray-200: #edf2f7;
    --gray-300: #e2e8f0;
    --gray-400: #cbd5e0;
    --gray-500: #a0aec0;
    --gray-600: #718096;
    --gray-700: #4a5568;
    --gray-800: #2d3748;
    --gray-900: #1a202c;
    --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
    --shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
    --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
    --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
    --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

* {
    box-sizing: border-box;
}

body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    margin: 0;
    padding: 0;
    color: var(--gray-900);
    line-height: 1.6;
}

body::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23ffffff' fill-opacity='0.03'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
    pointer-events: none;
    z-index: 0;
}

.container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 20px;
    position: relative;
    z-index: 1;
}

/* Typography */
h1 {
    font-size: 3.5rem;
    font-weight: 700;
    text-align: center;
    color: white;
    margin: 2rem 0 3rem;
    text-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    letter-spacing: -0.025em;
}

h2 {
    font-size: 1.875rem;
    font-weight: 600;
    color: var(--gray-900);
    margin-bottom: 1.5rem;
    letter-spacing: -0.025em;
}

h3 {
    font-size: 1.25rem;
    font-weight: 600;
    color: var(--gray-800);
    margin-bottom: 1rem;
}

/* Enhanced Form Styles */
form {
    background: white;
    border-radius: 16px;
    box-shadow: var(--shadow-xl);
    padding: 2rem;
    margin-bottom: 2rem;
    transition: var(--transition);
    border: 1px solid rgba(0, 0, 0, 0.05);
}

form:hover {
    transform: translateY(-2px);
    box-shadow: 0 25px 30px -10px rgba(0, 0, 0, 0.15);
}

label {
    display: block;
    font-weight: 500;
    color: var(--gray-700);
    margin-bottom: 0.5rem;
    font-size: 0.875rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
}

select, input[type="text"], input[type="url"], input[type="email"], input[type="password"], textarea {
    width: 100%;
    padding: 0.75rem 1rem;
    border: 2px solid var(--gray-300);
    border-radius: 8px;
    font-size: 1rem;
    transition: var(--transition);
    background: white;
    font-family: inherit;
}

select:focus, input:focus, textarea:focus {
    outline: none;
    border-color: var(--primary);
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
}

/* Enhanced Button Styles */
button {
    padding: 0.75rem 1.5rem;
    font-weight: 600;
    font-size: 0.875rem;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: var(--transition);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    position: relative;
    overflow: hidden;
    background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
    color: white;
}

button::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0;
    height: 0;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.2);
    transform: translate(-50%, -50%);
    transition: width 0.6s, height 0.6s;
}

button:active::before {
    width: 300px;
    height: 300px;
}

button:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow-lg);
}

button[type="submit"] {
    width: 100%;
    padding: 1rem;
    font-size: 1rem;
    margin-top: 2rem;
}

/* Action buttons (Disagree/Endorse) with distinct styling */
.disagree-premise-button, .endorse-conclusion-button {
    border: 2px solid;
    background: white;
    padding: 0.5rem 1rem;
    font-size: 0.875rem;
    font-weight: 600;
    border-radius: 50px;
    transition: all 0.3s ease;
    text-transform: none;
    letter-spacing: normal;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    position: relative;
    overflow: visible;
}

.disagree-premise-button {
    border-color: var(--danger);
    color: var(--danger);
}

.disagree-premise-button:hover {
    background: var(--danger);
    color: white;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(245, 101, 101, 0.3);
}

.disagree-premise-button:disabled {
    border-color: var(--gray-400);
    color: var(--gray-500);
    background: var(--gray-100);
    cursor: not-allowed;
    opacity: 0.6;
}

.disagree-premise-button:disabled:hover {
    transform: none;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.endorse-conclusion-button {
    border-color: var(--secondary);
    color: var(--secondary);
    margin-top: 1rem;
    padding: 0.75rem 2rem;
    font-size: 1rem;
}

.endorse-conclusion-button:hover {
    background: var(--secondary);
    color: white;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(72, 187, 120, 0.3);
}

.endorse-conclusion-button:disabled {
    border-color: var(--gray-400);
    color: var(--gray-500);
    background: var(--gray-100);
    cursor: not-allowed;
    opacity: 0.6;
}

.endorse-conclusion-button:disabled:hover {
    transform: none;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

#addPremiseButton {
    background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
}

#removePremiseButton {
    background: linear-gradient(135deg, var(--danger) 0%, #e53e3e 100%);
}

#checkFormValidityButton {
    background: linear-gradient(135deg, var(--secondary) 0%, #38a169 100%);
}

#defineStatementsNowButton {
    background: linear-gradient(135deg, var(--gray-600) 0%, var(--gray-700) 100%);
}

/* Authentication Container */
#authContainer {
    max-width: 800px;
    margin: 0 auto 2rem;
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 2rem;
}

#authContainer > div {
    background: white;
    padding: 2rem;
    border-radius: 16px;
    box-shadow: var(--shadow-xl);
}

#authContainer h2 {
    text-align: center;
    color: var(--primary);
    margin-bottom: 2rem;
}

/* Dynamic Argument Builder */
#dynamicArgumentBuilder {
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    border-radius: 16px;
    padding: 2rem;
    box-shadow: var(--shadow-xl);
    margin-top: 2rem;
}

.builder-container {
    display: grid;
    grid-template-columns: 300px 1fr;
    gap: 2rem;
    margin-top: 2rem;
}

/* Enhanced Palette */
.palette {
    background: var(--gray-100);
    border-radius: 12px;
    padding: 1.5rem;
    box-shadow: var(--shadow-md);
    position: sticky;
    top: 20px;
    max-height: calc(100vh - 40px);
    overflow-y: auto;
}

.palette h3 {
    color: var(--primary);
    font-size: 1.125rem;
    margin-bottom: 1rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
}

.palette-section h4 {
    font-size: 0.875rem;
    color: var(--gray-600);
    margin-bottom: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
}

.palette-item {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 0.5rem 1rem;
    margin: 0.25rem;
    border-radius: 8px;
    font-weight: 600;
    font-size: 0.875rem;
    cursor: grab;
    transition: var(--transition);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    min-width: 48px;
    box-shadow: var(--shadow-sm);
}

.palette-item:hover {
    transform: translateY(-2px) scale(1.05);
    box-shadow: var(--shadow-md);
}

.palette-item.proposition {
    color: white;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
}

/* Proposition Colors with Gradients */
.prop-a { background: linear-gradient(135deg, #E74C3C, #c0392b); }
.prop-b { background: linear-gradient(135deg, #3498DB, #2980b9); }
.prop-c { background: linear-gradient(135deg, #2ECC71, #27ae60); }
.prop-d { background: linear-gradient(135deg, #F1C40F, #f39c12); }
.prop-e { background: linear-gradient(135deg, #E67E22, #d35400); }
.prop-f { background: linear-gradient(135deg, #1ABC9C, #16a085); }
.prop-g { background: linear-gradient(135deg, #34495E, #2c3e50); }
.prop-h { background: linear-gradient(135deg, #7F8C8D, #6c7a7b); }
.prop-i { background: linear-gradient(135deg, #C0392B, #a93226); }
.prop-j { background: linear-gradient(135deg, #16A085, #138d75); }
.prop-k { background: linear-gradient(135deg, #9B59B6, #8e44ad); }

.palette-item.operator {
    background: linear-gradient(135deg, var(--gray-200), var(--gray-300));
    color: var(--gray-700);
    border: 1px solid var(--gray-400);
    font-family: 'JetBrains Mono', 'Courier New', monospace;
}

/* Enhanced Workspace */
.workspace {
    background: white;
    border-radius: 12px;
    padding: 2rem;
    box-shadow: var(--shadow-md);
}

.premise-slot {
    background: var(--gray-50);
    border: 2px dashed var(--gray-300);
    border-radius: 12px;
    padding: 1.5rem;
    margin-bottom: 1rem;
    transition: var(--transition);
}

.premise-slot:hover {
    border-color: var(--gray-400);
    background: var(--gray-100);
}

.drop-zone {
    min-height: 60px;
    padding: 1rem;
    background: white;
    border: 2px solid var(--gray-300);
    border-radius: 8px;
    transition: var(--transition);
    display: flex;
    align-items: center;
}

.drop-zone.drag-over {
    background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(102, 126, 234, 0.2));
    border-color: var(--primary);
    transform: scale(1.02);
}

.sub-drop-zone {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 0.5rem 1rem;
    border: 2px dashed var(--gray-400);
    border-radius: 6px;
    min-width: 60px;
    min-height: 40px;
    background: var(--gray-50);
    margin: 0 0.25rem;
    transition: var(--transition);
}

.sub-drop-zone:hover {
    background: var(--gray-100);
    border-color: var(--primary);
}

/* Conclusion Area */
.conclusion-area {
    background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(102, 126, 234, 0.05));
    border: 2px solid var(--primary);
    border-radius: 12px;
    padding: 1.5rem;
    margin-top: 2rem;
}

/* Trash Can */
#trashCanArea {
    background: linear-gradient(135deg, var(--gray-100), var(--gray-200));
    border: 2px dashed var(--gray-400);
    border-radius: 12px;
    padding: 1.5rem;
    text-align: center;
    transition: var(--transition);
    cursor: pointer;
    margin-top: 2rem;
}

#trashCanArea:hover {
    background: linear-gradient(135deg, #fee2e2, #fecaca);
    border-color: var(--danger);
    transform: scale(1.02);
}

#trashCanArea i {
    font-size: 2rem;
    color: var(--gray-600);
    transition: var(--transition);
}

#trashCanArea:hover i {
    color: var(--danger);
    transform: scale(1.1);
}

/* Enhanced Arguments Display */
.argument {
    background: white;
    border-radius: 16px;
    padding: 2rem;
    margin-bottom: 2rem;
    box-shadow: var(--shadow-lg);
    border-left: 4px solid var(--primary);
    transition: var(--transition);
}

.argument:hover {
    transform: translateX(4px);
    box-shadow: var(--shadow-xl);
}

.argument-header {
    display: flex;
    align-items: center;
    gap: 1.5rem;
    margin-bottom: 1.5rem;
}

.argument-icon {
    font-size: 3rem;
    color: var(--primary);
    background: rgba(102, 126, 234, 0.1);
    width: 80px;
    height: 80px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
}

.argument-content li {
    position: relative;
    padding: 1.5rem;
    margin-bottom: 1rem;
    background: var(--gray-50);
    border-radius: 12px;
    border-left: 3px solid var(--primary);
    transition: var(--transition);
}

/* Fix for ordered list numbers */
.argument-content ol {
    list-style-type: decimal;
    list-style-position: outside;
    padding-left: 30px;
    margin-left: 10px;
}

.argument-content li:hover {
    background: var(--gray-100);
    transform: translateX(4px);
}
.argument-content li:hover {
    background: var(--gray-100);
    transform: translateX(4px);
}

/* Filter Section */
.argument-filters {
    background: white;
    border-radius: 16px;
    padding: 2rem;
    box-shadow: var(--shadow-lg);
    margin-bottom: 2rem;
}

.argument-filters h2 {
    margin-bottom: 1.5rem;
}

.argument-filters > div {
    margin-bottom: 1.5rem;
}

@media (max-width: 768px) {
    .argument-filters > div {
        grid-template-columns: 1fr !important;
    }
}

/* Mobile Responsive Improvements */
@media (max-width: 768px) {
    h1 { font-size: 2.5rem; }
    
    .container { padding: 1rem; }
    
    #authContainer { grid-template-columns: 1fr; }
    
    .builder-container { grid-template-columns: 1fr; }
    
    .palette {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        max-height: 40vh;
        border-radius: 16px 16px 0 0;
        z-index: 50;
        box-shadow: 0 -4px 6px -1px rgba(0, 0, 0, 0.1);
    }
    
    .argument-header {
        flex-direction: column;
        text-align: center;
    }
    
    /* Mobile-specific argument content styling */
    .argument-content {
        overflow-x: hidden;
    }
    
    .argument-content ol {
        padding-left: 0;
        margin-left: 0;
    }
    
    .argument-content li {
        display: block;
        padding: 1rem;
        margin-bottom: 1rem;
    }
    
    /* Ensure formula groups wrap properly on mobile */
    .argument-content span[style*="inline-block"] {
        max-width: 100% !important;
        word-wrap: break-word !important;
    }
    
    /* Adjust buttons on mobile */
    .disagree-premise-button,
    .endorse-conclusion-button {
        display: block;
        width: 100%;
        margin: 10px 0 0 0 !important;
    }
    
    /* Premise URL links */
    .premise-url {
        display: block;
        margin-top: 10px;
        word-break: break-all;
    }
}

/* Info boxes */
.info-box {
    background: linear-gradient(135deg, rgba(66, 153, 225, 0.1), rgba(66, 153, 225, 0.05));
    border: 1px solid var(--info);
    border-radius: 8px;
    padding: 1rem;
    margin: 1rem 0;
    font-size: 0.875rem;
    color: var(--gray-700);
}

/* Validity Result */
#validityResult {
    padding: 1rem;
    border-radius: 8px;
    margin-top: 1rem;
    font-weight: 500;
    text-align: center;
}

/* Statement Definition Area */
#statementDefinitionArea {
    background: var(--gray-50);
    border-radius: 12px;
    padding: 2rem;
    margin-top: 2rem;
    border: 2px solid var(--gray-300);
}

/* Animations */
@keyframes slideIn {
    from {
        opacity: 0;
        transform: translateY(-10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.combination-prompt {
    animation: slideIn 0.3s ease-out;
}

/* Formula element selection */
.formula-element-wrapper.selected-formula-element > div {
    outline: 3px solid var(--primary);
    outline-offset: 3px;
    box-shadow: 0 0 0 6px rgba(102, 126, 234, 0.2);
}
/* Mobile-friendly proposition bubbles in arguments */
.argument-content .palette-item.proposition {
    display: inline-block !important;
    max-width: 100% !important;
    white-space: normal !important;
    word-wrap: break-word !important;
    word-break: normal !important;
    hyphens: auto !important;
    margin: 4px 2px !important;
    padding: 6px 12px !important;
    line-height: 1.4 !important;
    vertical-align: middle !important;
}

@media (max-width: 768px) {
    .argument-content .palette-item.proposition {
        font-size: 0.8rem !important;
        padding: 4px 8px !important;
        margin: 2px !important;
    }
    
    .argument-content .formula-group {
        display: inline !important;
        white-space: normal !important;
    }
    
    .argument-content li {
        padding: 1rem !important;
    }
    
    /* Ensure premise text containers are full width on mobile */
    .premise-text {
        width: 100%;
        display: block;
        margin-bottom: 10px;
    }
    
    /* Stack buttons vertically on mobile */
    .premise-vote-container {
        width: 100%;
        margin-left: 0 !important;
        margin-top: 10px;
    }
    
    .disagree-premise-button,
    .endorse-conclusion-button {
        width: 100%;
        text-align: center;
    }
/* Premise numbering and improved mobile layout */
.premise-number {
    display: block;
    font-weight: bold;
    color: var(--primary);
    margin-bottom: 8px;
    font-size: 0.9rem;
}

@media (max-width: 768px) {
    .argument-content li {
        position: relative;
        padding-left: 0;
        border-left: 3px solid var(--primary);
        background-color: var(--gray-50);
        margin-bottom: 1.5rem;
    }
    
    /* Make operator groups more distinct on mobile */
    .argument-content span[style*="backgroundColor"] {
        display: block !important;
        margin: 8px 0 !important;
        padding: 8px !important;
        border-radius: 8px !important;
    }
}
}
/* Beautiful premise numbering */
.argument-content ol {
    counter-reset: premise-counter;
    list-style: none;
    padding-left: 0;
    margin: 0;
}

.argument-content ol li {
    counter-increment: premise-counter;
    position: relative;
    margin-bottom: 1.5rem;
    padding-left: 0;
}

.argument-content ol li::before {
    content: "Premise " counter(premise-counter);
    display: block;
    font-weight: 600;
    color: var(--primary);
    font-size: 0.875rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: 0.75rem;
}

/* Special styling for the conclusion */
.argument-content ol li:last-child::before {
    content: "Conclusion";
    color: var(--secondary);
}

/* Adjust the premise text container */
.argument-content .premise-text {
    display: block;
    width: 100%;
    margin-bottom: 1rem;
}

/* Mobile adjustments */
@media (max-width: 768px) {
    .argument-content ol li {
        padding: 1rem;
    }
    
    .argument-content ol li::before {
        font-size: 0.8rem;
    }
}
    </style>
</head>
<body>
    <div class="pull-to-refresh">
        <i class="fas fa-sync"></i> <span style="margin-left: 10px;">Pull to refresh</span>
    </div>
    
    <!-- Mobile Alert Container -->
    <div id="mobileAlert" class="mobile-alert" role="alert"></div>
    
    <div class="container">
        <h1>Crux</h1>

        <div id="authContainer">
            <div id="registerForm">
                <h2>Register</h2>
                <input type="email" id="registerEmail" placeholder="Email" required>
                <input type="password" id="registerPassword" placeholder="Password" required>
                <button type="button" onclick="register()">Register</button>
            </div>
            <div id="loginForm">
                <h2>Login</h2>
                <input type="email" id="loginEmail" placeholder="Email" required>
                <input type="password" id="loginPassword" placeholder="Password" required>
                <button type="button" onclick="login()">Login</button>
            </div>
        </div>

        <button id="logoutButton" type="button" onclick="logout()" style="display:none;">Logout</button>

        <form id="claimSetupForm"> 
            <h2>1. Define Your Argument's Main Claim</h2>
            <label for="categorySelect">Category:</label>
            <select id="categorySelect" required> <option value="">-- Choose a Category --</option></select>
            
            <label for="subcategorySelect">Subcategory:</label>
            <select id="subcategorySelect" required> <option value="">-- Choose a Subcategory --</option> </select>
            
            <label for="claimSelect">Main Claim Statement (K):</label>
            <select id="claimSelect" required> <option value="">-- Choose a Claim --</option> </select>
            
            <label for="stanceSelect">Your Stance on this Claim:</label>
            <select id="stanceSelect" required> 
                <option value="">-- Choose Your Stance --</option> 
                <option value="For">I will argue FOR this claim (Conclusion: K)</option> 
                <option value="Against">I will argue AGAINST this claim (Conclusion: NOT K)</option> 
            </select>
            <button type="button" id="setClaimAndBuildButton">Set Claim & Build Argument Form</button>
        </form>
        
        <form id="argumentForm" style="display:none;">
             <h2>Submit Argument (Template System - Deprecated)</h2>
             <p>This submission method is being phased out. Please use the "Define Your Argument's Main Claim" section above.</p>
             <label for="argumentTitle">Argument Title (Old Template)</label>
            <input type="text" id="argumentTitleOld" placeholder="Enter argument title">
            <div id="argumentFormsContainer" style="display:none;"></div>
            <div id="placeholders" class="placeholders" style="display:none;"></div>
            <button type="submit" id="submitTemplateArgumentButton" style="display:none;">Submit Template Argument</button>
        </form>


        <div id="dynamicArgumentBuilder" style="display:none;">
            <h2>2. Build Your Argument Form</h2>
            <div style="margin-bottom: 15px; padding: 10px; background-color: #e9ecef; border-radius: 4px; border: 1px solid #ced4da;">
                <strong>Main Claim (K):</strong> <span id="displayMainClaimK" style="font-style: italic;">Not yet set</span><br>
                <strong>Your Stance:</strong> You are arguing <span id="displayStanceOnK" style="font-weight:bold;">N/A</span> this claim.
            </div>
            <div class="builder-container">
                <div class="palette">
                    <h3>Palette</h3>
                    <div class="palette-section">
                        <h4>Propositions:</h4>
                        <div class="palette-item proposition prop-a" draggable="true" data-type="proposition" data-letter="A">A</div>
                        <div class="palette-item proposition prop-b" draggable="true" data-type="proposition" data-letter="B">B</div>
                        <div class="palette-item proposition prop-c" draggable="true" data-type="proposition" data-letter="C">C</div>
                        <div class="palette-item proposition prop-d" draggable="true" data-type="proposition" data-letter="D">D</div>
                        <div class="palette-item proposition prop-e" draggable="true" data-type="proposition" data-letter="E">E</div>
                        <div class="palette-item proposition prop-f" draggable="true" data-type="proposition" data-letter="F">F</div>
                        <div class="palette-item proposition prop-g" draggable="true" data-type="proposition" data-letter="G">G</div>
                        <div class="palette-item proposition prop-h" draggable="true" data-type="proposition" data-letter="H">H</div>
                        <div class="palette-item proposition prop-i" draggable="true" data-type="proposition" data-letter="I">I</div>
                        <div class="palette-item proposition prop-j" draggable="true" data-type="proposition" data-letter="J">J</div>
                        <div class="palette-item proposition prop-k" draggable="true" data-type="proposition" data-letter="K" title="This is your Main Claim">K (Main Claim)</div>
                    </div>
                    <div class="palette-section">
                        <h4>Operators:</h4>
                        <div class="palette-item operator op-ifthen" draggable="true" data-type="operator" data-operator="IFTHEN">IF...THEN</div>
                        <div class="palette-item operator op-and" draggable="true" data-type="operator" data-operator="AND">AND</div>
                        <div class="palette-item operator op-or" draggable="true" data-type="operator" data-operator="OR">OR</div>
                        <div class="palette-item operator op-not" draggable="true" data-type="operator" data-operator="NOT">NOT</div>
                    </div>
                     <div id="trashCanArea" style="margin-top: 20px; padding: 10px; border: 2px dashed #ccc; text-align: center; background-color: #f0f0f0;">
                        <i class="fas fa-trash" style="font-size: 24px; color: #777;"></i>
                        <p style="font-size: 12px; color: #777; margin-top: 5px;">Drag here or click selected to delete</p>
                    </div>
                </div>
                <div class="workspace">
                    <h3>Construct Premises:</h3>
                     <label for="dynamicArgumentTitle">Argument Title for this Structure:</label>
                    <input type="text" id="dynamicArgumentTitle" placeholder="Enter title for this argument structure" style="margin-bottom:15px;">
                    <div id="premisesContainer">
                        <div class="premise-slot" id="premise-1-slot-container"> 
                            <span class="premise-label">Premise 1:</span>
                            <div class="drop-zone" id="premise-1-dropzone" data-premise-id="1">[Drop content here]</div>
                            <div class="premise-url-container" style="margin-top: 10px;">
                                <label style="font-size: 14px; font-weight: normal;">Evidence URL (optional):</label>
                                <input type="url" class="premise-url-input" id="premise-1-url" placeholder="https://example.com/evidence" style="width: 100%; margin-top: 5px;">
                                <small style="color: #666; font-size: 12px;">Enter full URL or just domain (e.g., example.com)</small>
                            </div>
                        </div>
                        <div class="premise-slot" id="premise-2-slot-container">
                            <span class="premise-label">Premise 2:</span>
                            <div class="drop-zone" id="premise-2-dropzone" data-premise-id="2">[Drop content here]</div>
                            <div class="premise-url-container" style="margin-top: 10px;">
                                <label style="font-size: 14px; font-weight: normal;">Evidence URL (optional):</label>
                                <input type="url" class="premise-url-input" id="premise-2-url" placeholder="https://example.com/evidence" style="width: 100%; margin-top: 5px;">
                                <small style="color: #666; font-size: 12px;">Enter full URL or just domain (e.g., example.com)</small>
                            </div>
                        </div>
                    </div>
                    <button id="addPremiseButton" type="button">+ Add Premise</button>
                    <button id="removePremiseButton" type="button" style="background-color: #dc3545; margin-left: 10px;">- Remove Last Premise</button>
                    <button id="defineStatementsNowButton" type="button" style="background-color: #6c757d; margin-left: 10px;">Define Statements (A, B, C...)</button>
                    
                    <div class="conclusion-area">
                        <span class="conclusion-label">Target Conclusion Form:</span>
                        <div class="conclusion-placeholder" id="conclusionPlaceholder">( K )</div> 
                    </div>
                    <div style="margin-top: 10px; padding: 10px; background-color: #f8f9fa; border-radius: 4px; font-size: 14px; color: #666;">
                        <strong>Tip:</strong> To create nested formulas like "IF A THEN (B OR C)", first drop the IF...THEN operator, then drop B and C into the empty slots that appear.
                    </div>
                    <hr style="margin: 20px 0;">
                    <button id="checkFormValidityButton" type="button">Validate Form Structure</button>
                    <div id="validityResult" style="margin-top: 10px; font-weight: bold;"></div>
                    <button id="defineStatementsButton" type="button" style="display:none; background-color: #007bff; margin-top:15px;">Next: Define Statements (A, B, C...)</button>
                </div>
            </div>
            <div id="statementDefinitionArea" style="margin-top: 20px; padding:15px; border:1px solid #ccc; background-color:#fff;">
                <h3>3. Define Your Statements</h3>
                <div id="statementInputsContainer">
                    <p style="color: #666; font-style: italic;">Click on any proposition letter (A, B, C, etc.) in your premises above to define what it represents, or click "Define Statements" to define all at once.</p>
                </div>
                <button id="submitDynamicArgumentButton" type="button" style="background-color: #28a745; margin-top:15px;">Submit Final Argument</button>
            </div>
        </div>
        <hr style="margin: 40px 0;"> 

        <div class="argument-filters">
            <h2>View Submitted Arguments</h2>
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                <div>
                    <label for="filterClaimSelect">Filter by Claim:</label>
                    <select id="filterClaimSelect"> <option value="">-- All Claims --</option> </select>
                </div>
                <div>
                    <label for="filterStanceSelect">Filter by Stance:</label>
                    <select id="filterStanceSelect"> <option value="">-- All Stances --</option> <option value="For">For</option> <option value="Against">Against</option> </select>
                </div>
                <div>
                    <label for="rankingSelect">Sort By:</label>
                    <select id="rankingSelect"> 
                        <option value="random">Random</option>
                        <option value="mostRecent">Most Recent</option> 
                        <option value="mostEndorsed">Most Endorsed</option> 
                        <option value="highestPercentage">Highest Endorsement Percentage</option> 
                    </select>
                </div>
            </div>
            <button type="button" onclick="displayArguments()" id="filterButton">Show Argument</button>
            <button type="button" onclick="displayArguments(true)" id="nextButton" style="display: none; margin-left: 10px; background-color: #6c757d;">Show Another</button>
        </div>

        <div id="argumentsList"></div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/9.17.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.17.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.17.1/firebase-firestore-compat.js"></script>

    <script>
        console.log("Script 1: Starting initialization");
        
        // Initialize Firebase immediately
        const firebaseConfig = {
          apiKey: "AIzaSyBujX8q4fDGROi4PEMAEq13NrwNNlAHBzo", 
          authDomain: "crux-da4ec.firebaseapp.com", 
          projectId: "crux-da4ec", 
          storageBucket: "crux-da4ec.firebasestorage.app", 
          messagingSenderId: "230106844798", 
          appId: "1:230106844798:web:7b0230b27a9caa7d6a522f" 
        };
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        
        console.log("Script 1: Firebase initialized");

        // Define all global variables
        let selectedClaimTextForK = ''; 
        let selectedStanceForK = '';   
        let selectedArgumentForm = null; 
        let selectedClaimText = '';    
        let selectedStanceText = '';

        // Define authentication functions globally
        function register() {
            var email = document.getElementById('registerEmail').value;
            var password = document.getElementById('registerPassword').value;

            firebase.auth().createUserWithEmailAndPassword(email, password)
                .then((userCredential) => {
                    alert('Registration successful!');
                    document.getElementById('registerEmail').value = '';
                    document.getElementById('registerPassword').value = '';
                })
                .catch((error) => {
                    alert(error.message);
                });
        }

        function login() {
            var email = document.getElementById('loginEmail').value;
            var password = document.getElementById('loginPassword').value;

            firebase.auth().signInWithEmailAndPassword(email, password)
                .then((userCredential) => {
                    alert('Login successful!');
                    document.getElementById('loginEmail').value = '';
                    document.getElementById('loginPassword').value = '';
                })
                .catch((error) => {
                    alert(error.message);
                });
        }

        function logout() {
            firebase.auth().signOut().then(() => {
                alert('Logged out successfully!');
            }).catch((error) => {
                alert(error.message);
            });
        }
        
        console.log("Script 1: Auth functions defined");
        
        // Helper function to create an editable proposition bubble
        window.createEditablePropositionBubble = function(letter, text, isInPalette = false) {
            const bubble = document.createElement('span');
            bubble.className = `palette-item proposition prop-${letter.toLowerCase()}`;
            bubble.style.display = 'inline-block';
            bubble.style.position = 'relative';

            // Only make it clickable if it's in a premise or conclusion area
            if (!isInPalette) {
                bubble.style.cursor = letter === 'K' ? 'default' : 'pointer';
                bubble.title = letter === 'K' ? 'Main claim (cannot be edited)' : 'Click to edit statement';
            } else {
                // In palette - not editable
                bubble.style.cursor = 'grab';
                bubble.title = `Drag ${letter} to a premise`;
            }
            
            // Add hover effect
            bubble.style.transition = 'transform 0.2s';
            bubble.onmouseover = function() {
                this.style.transform = 'scale(1.05)';
            };
            bubble.onmouseout = function() {
                this.style.transform = 'scale(1)';
            };
            
            if (text && text.trim() !== '') {
                // Show text with proper formatting
                bubble.classList.add('with-text');
                bubble.innerHTML = `<strong>${letter}:</strong> ${text}`;
                bubble.title = `${letter}: ${text}`; // Show full text on hover
            } else {
                bubble.textContent = letter;
            }
            
            // Only add click handler if not in palette and not K
            if (!isInPalette && letter !== 'K') {
                bubble.onclick = function(e) {
                    e.stopPropagation();
                    if (window.editPropositionText && typeof window.editPropositionText === 'function') {
                        window.editPropositionText(letter);
                    }
                };
            }
            
            // Special styling for K to indicate it's not editable
            if (letter === 'K') {
                bubble.style.cursor = 'default';
                bubble.title = 'Main claim (cannot be edited)';
                bubble.onclick = function(e) {
                    e.stopPropagation();
                    // Do nothing for K
                };
            }
            
            return bubble;
        };
        
        // Make functions globally available for dynamicBuilderUI.js
        window.argumentWorkspace = window.argumentWorkspace || { premises: {}, conclusionAST_form: null };
        window.statementDefinitions = window.statementDefinitions || {};
        window.selectedFormulaElementInfo = null;
    </script>

    <script>
        // Validation Engine Functions (from validationEngine.js)
        /**
         * Extracts all unique propositional letters from an array of ASTs.
         */
        function extractUniquePropositions(astArray) {
            const letters = new Set();

            function traverse(node) {
                if (!node) return;

                if (node.type === 'proposition') {
                    if (node.letter) {
                        letters.add(node.letter);
                    } else {
                        console.warn("extractUniquePropositions: Proposition node encountered without a letter property.", node);
                    }
                } else if (node.type === 'operator') {
                    if (node.operand) {
                        traverse(node.operand);
                    }
                    if (node.operands) {
                        node.operands.forEach(traverse);
                    }
                }
            }

            if (Array.isArray(astArray)) {
                astArray.forEach(traverse);
            } else {
                console.warn("extractUniquePropositions: Input was not an array.", astArray);
            }
            return Array.from(letters).sort();
        }

        /**
         * Generates all possible truth assignments for a given list of proposition letters.
         */
        function generateTruthAssignments(propositionLetters) {
            const assignments = [];
            const n = propositionLetters.length;

            if (n === 0) {
                return [{}]; 
            }

            const totalAssignments = 1 << n;

            for (let i = 0; i < totalAssignments; i++) {
                const currentAssignment = {};
                for (let j = 0; j < n; j++) {
                    currentAssignment[propositionLetters[j]] = ((i >> j) & 1) === 1;
                }
                assignments.push(currentAssignment);
            }
            return assignments;
        }

        /**
         * Evaluates the truth value of a logical formula (AST) given specific truth assignments.
         */
        function evaluateFormula(formulaAST, truthAssignments) {
            if (!formulaAST || typeof formulaAST.type !== 'string') {
                console.error("evaluateFormula Error: AST node is null, undefined, or missing a 'type'. Provided:", formulaAST);
                throw new Error("Invalid AST node structure provided to evaluateFormula.");
            }

            if (formulaAST.type === 'proposition') {
                if (!formulaAST.hasOwnProperty('letter')) {
                    console.error("evaluateFormula Error: Proposition node missing 'letter'.", formulaAST);
                    throw new Error("Malformed proposition node: missing 'letter'.");
                }
                if (truthAssignments.hasOwnProperty(formulaAST.letter)) {
                    return truthAssignments[formulaAST.letter];
                } else {
                    console.warn(`evaluateFormula Warning: Truth value for proposition '${formulaAST.letter}' not found in current assignments. Defaulting to false.`);
                    return false; 
                }
            }

            if (formulaAST.type === 'operator') {
                if (!formulaAST.operator) {
                    console.error("evaluateFormula Error: Operator node missing 'operator' property.", formulaAST);
                    throw new Error("Malformed operator node: missing 'operator'.");
                }
                switch (formulaAST.operator) {
                    case 'NOT':
                        if (!formulaAST.operand) throw new Error("NOT operator missing operand.");
                        return !evaluateFormula(formulaAST.operand, truthAssignments);
                    case 'AND':
                        if (!formulaAST.operands || formulaAST.operands.length !== 2) throw new Error("AND operator requires 2 operands.");
                        return evaluateFormula(formulaAST.operands[0], truthAssignments) &&
                               evaluateFormula(formulaAST.operands[1], truthAssignments);
                    case 'OR':
                        if (!formulaAST.operands || formulaAST.operands.length !== 2) throw new Error("OR operator requires 2 operands.");
                        return evaluateFormula(formulaAST.operands[0], truthAssignments) ||
                               evaluateFormula(formulaAST.operands[1], truthAssignments);
                    case 'IFTHEN':
                        if (!formulaAST.operands || formulaAST.operands.length !== 2) throw new Error("IFTHEN operator requires 2 operands.");
                        const antecedentVal = evaluateFormula(formulaAST.operands[0], truthAssignments);
                        const consequentVal = evaluateFormula(formulaAST.operands[1], truthAssignments);
                        return !antecedentVal || consequentVal;
                    default:
                        console.error(`evaluateFormula Error: Unknown operator '${formulaAST.operator}'.`);
                        throw new Error(`Unknown operator: ${formulaAST.operator}`);
                }
            }

            console.error("evaluateFormula Error: Unknown AST node type.", formulaAST);
            throw new Error(`Unknown AST node type: ${formulaAST.type}`);
        }

        /**
         * Checks if an argument form (premises + conclusion) is logically valid.
         */
        function isArgumentFormValid(premiseASTs, conclusionAST) {
            if (!Array.isArray(premiseASTs) || !conclusionAST) {
                console.error("isArgumentFormValid Error: Invalid input. `premiseASTs` must be an array and `conclusionAST` must be provided.");
                return false; 
            }

            const allInvolvedASTs = [...premiseASTs, conclusionAST];
            const uniquePropositions = extractUniquePropositions(allInvolvedASTs);
            const truthAssignmentsList = generateTruthAssignments(uniquePropositions);

            if (truthAssignmentsList.length === 0 && uniquePropositions.length > 0) {
                console.error("isArgumentFormValid Error: Failed to generate truth assignments for identified propositions.");
                return false;
            }

            for (const currentAssignments of truthAssignmentsList) {
                let allPremisesAreTrue = true;
                if (premiseASTs.length > 0) {
                    for (const premise of premiseASTs) {
                        if (!evaluateFormula(premise, currentAssignments)) {
                            allPremisesAreTrue = false;
                            break; 
                        }
                    }
                }

                if (allPremisesAreTrue) {
                    if (!evaluateFormula(conclusionAST, currentAssignments)) {
                        console.log("Argument form is INVALID. Counterexample found with assignments:", currentAssignments);
                        return false; 
                    }
                }
            }
            return true;
        }
        
        /**
         * Checks if a set of premises is consistent (can all be true at the same time)
         */
        function arePremisesConsistent(premiseASTs) {
            if (!Array.isArray(premiseASTs) || premiseASTs.length === 0) {
                return true; // Empty set is consistent
            }

            const uniquePropositions = extractUniquePropositions(premiseASTs);
            const truthAssignmentsList = generateTruthAssignments(uniquePropositions);

            // Check if there exists at least one assignment where all premises are true
            for (const currentAssignments of truthAssignmentsList) {
                let allPremisesTrue = true;
                
                for (const premise of premiseASTs) {
                    if (!evaluateFormula(premise, currentAssignments)) {
                        allPremisesTrue = false;
                        break;
                    }
                }
                
                if (allPremisesTrue) {
                    return true; // Found an assignment where all premises are true
                }
            }
            
            return false; // No assignment makes all premises true
        }
        
        // Make function globally available
        window.arePremisesConsistent = arePremisesConsistent;
    </script>
    <script src="dynamicBuilderUI.js"></script>  

    <script>
        // Trash can functionality
        document.addEventListener('DOMContentLoaded', function() {
            console.log("Setting up trash can functionality");
            
            const trashCanArea = document.getElementById('trashCanArea');
            if (trashCanArea) {
                // Make trash can clickable to delete selected element
                trashCanArea.addEventListener('click', function(e) {
                    e.stopPropagation(); // Prevent deselection
                    console.log("Trash can clicked");
                    
                    // Check if there's a selected element
                    const selectedElement = document.querySelector('.selected-formula-element');
                    if (selectedElement) {
                        console.log("Found selected element to delete via trash click");
                        
                        // Make sure selectedFormulaElementInfo is set correctly
                        if (!window.selectedFormulaElementInfo) {
                            // Reconstruct the selection info from the element
                            window.selectedFormulaElementInfo = {
                                domElement: selectedElement,
                                premiseId: selectedElement.dataset.premiseId || '',
                                path: selectedElement.dataset.path || ''
                            };
                        }
                        
                        console.log("Current selectedFormulaElementInfo:", window.selectedFormulaElementInfo);
                        
                        // Trigger delete using the same method that works for drag
                        const deleteEvent = new KeyboardEvent('keydown', {
                            key: 'Delete',
                            code: 'Delete',
                            keyCode: 46,
                            which: 46,
                            bubbles: true,
                            cancelable: true
                        });
                        document.dispatchEvent(deleteEvent);
                    } else {
                        console.log("No element selected to delete");
                    }
                });
                
                // Prevent default drag over to allow drop
                trashCanArea.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = "move";
                    this.style.backgroundColor = '#ffcccc';
                    this.style.borderColor = '#ff0000';
                });
                
                // Remove drag over effect
                trashCanArea.addEventListener('dragleave', function() {
                    this.style.backgroundColor = '#f0f0f0';
                    this.style.borderColor = '#ccc';
                });
                
                // Handle drop on trash - properly delete the dragged element
                trashCanArea.addEventListener('drop', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log("Element dropped on trash");
                    
                    // Reset trash can appearance
                    this.style.backgroundColor = '#f0f0f0';
                    this.style.borderColor = '#ccc';
                    
                    try {
                        // Get the data from the drag event
                        const dragData = e.dataTransfer.getData('application/json');
                        if (dragData) {
                            const data = JSON.parse(dragData);
                            console.log("Dropped data:", data);
                            
                            // Check if it's a formula element being dragged
                            if (data.type === 'formula-element' && data.premiseId) {
                                console.log(`Looking for element with premise-id="${data.premiseId}" and path="${data.path || ''}"`);
                                
                                // Find all matching elements
                                const matchingElements = document.querySelectorAll(
                                    `.formula-element-wrapper[data-premise-id="${data.premiseId}"]`
                                );
                                
                                console.log(`Found ${matchingElements.length} elements with matching premise ID`);
                                
                                // Find the exact element by path
                                let elementToDelete = null;
                                matchingElements.forEach(el => {
                                    if (el.dataset.path === (data.path || '')) {
                                        elementToDelete = el;
                                        console.log("Found exact match for deletion");
                                    }
                                });
                                
                                if (elementToDelete) {
                                    console.log("Found element to delete:", elementToDelete);
                                    
                                    // Directly manipulate the selection state like dynamicBuilderUI.js does
                                    // First, clear any existing selection
                                    const currentlySelected = document.querySelector('.selected-formula-element');
                                    if (currentlySelected && currentlySelected !== elementToDelete) {
                                        currentlySelected.classList.remove('selected-formula-element');
                                    }
                                    
                                    // Select the element
                                    elementToDelete.classList.add('selected-formula-element');
                                    
                                    // Set the global selection info that dynamicBuilderUI.js uses
                                    if (!window.selectedFormulaElementInfo) {
                                        window.selectedFormulaElementInfo = {};
                                    }
                                    window.selectedFormulaElementInfo.domElement = elementToDelete;
                                    window.selectedFormulaElementInfo.premiseId = data.premiseId;
                                    window.selectedFormulaElementInfo.path = data.path || '';
                                    
                                    console.log("Set selectedFormulaElementInfo:", window.selectedFormulaElementInfo);
                                    
                                    // Now trigger deletion using the exact same approach as clicking trash
                                    setTimeout(() => {
                                        console.log("Triggering delete after setting selection");
                                        
                                        // This mimics what happens when you click the trash can
                                        const deleteEvent = new KeyboardEvent('keydown', {
                                            key: 'Delete',
                                            code: 'Delete',
                                            keyCode: 46,
                                            which: 46,
                                            bubbles: true,
                                            cancelable: true
                                        });
                                        document.dispatchEvent(deleteEvent);
                                    }, 50);
                                } else {
                                    console.error("Could not find element to delete");
                                    
                                    // Fallback: use the globally stored reference
                                    if (window.currentlyDraggedElement) {
                                        console.log("Using fallback - globally stored dragged element");
                                        window.currentlyDraggedElement.click();
                                        setTimeout(() => {
                                            const deleteEvent = new KeyboardEvent('keydown', {
                                                key: 'Delete',
                                                code: 'Delete',
                                                keyCode: 46,
                                                which: 46,
                                                bubbles: true,
                                                cancelable: true
                                            });
                                            document.dispatchEvent(deleteEvent);
                                        }, 50);
                                    }
                                }
                            } else {
                                console.log("Dropped item is not a formula element or missing premise ID");
                            }
                        } else {
                            console.log("No drag data available");
                        }
                    } catch (error) {
                        console.error("Error processing drop:", error);
                    }
                    
                    // Clean up any dragging state
                    const draggingItem = document.querySelector('.dragging');
                    if (draggingItem) {
                        draggingItem.classList.remove('dragging');
                    }
                    
                    // Clear global reference
                    window.currentlyDraggedElement = null;
                });
            }
            
            // Add a helper function to delete selected element
            window.deleteSelectedElement = function() {
                // Try to trigger the delete key event in a way that dynamicBuilderUI.js will recognize
                const activeElement = document.activeElement;
                const deleteEvent = new KeyboardEvent('keydown', {
                    key: 'Delete',
                    code: 'Delete',
                    keyCode: 46,
                    which: 46,
                    bubbles: true,
                    cancelable: true,
                    view: window,
                    ctrlKey: false,
                    altKey: false,
                    shiftKey: false,
                    metaKey: false
                });
                
                // Try dispatching on multiple targets
                if (activeElement) {
                    activeElement.dispatchEvent(deleteEvent);
                }
                document.dispatchEvent(deleteEvent);
                window.dispatchEvent(deleteEvent);
            };
            
            // Add functionality to edit proposition text
            window.editPropositionText = function(letter) {
                // Don't allow editing K
                if (letter === 'K') {
                    alert('The main claim (K) cannot be edited here. It was defined when you selected your claim.');
                    return;
                }
                
                // Show a prompt to get the new text
                const currentText = window.statementDefinitions && window.statementDefinitions[letter] ? window.statementDefinitions[letter] : '';
                const newText = prompt(`Enter the statement for ${letter}:`, currentText);
                
                if (newText !== null && newText.trim() !== '') {
                    // Store the definition
                    if (!window.statementDefinitions) {
                        window.statementDefinitions = {};
                    }
                    window.statementDefinitions[letter] = newText.trim();
                    
                    // Update all instances of this letter in the UI
                    updateAllPropositionDisplays();
                    
                    // Make the draggable elements again after re-rendering
                    setTimeout(() => {
                        const makeElementsDraggable = document.querySelector('#premisesContainer').__makeElementsDraggable;
                        if (makeElementsDraggable) {
                            makeElementsDraggable();
                        }
                    }, 100);
                }
            };
            
            // Function to update all proposition displays
            window.updateAllPropositionDisplays = function() {
                // Re-render all premises to show updated text
                if (window.argumentWorkspace && window.argumentWorkspace.premises) {
                    Object.keys(window.argumentWorkspace.premises).forEach(premiseId => {
                        if (window.renderTopLevelPremise && typeof window.renderTopLevelPremise === 'function') {
                            window.renderTopLevelPremise(premiseId);
                        }
                    });
                }
                
                // Update conclusion if it contains K
                const conclusionPlaceholder = document.getElementById('conclusionPlaceholder');
                if (conclusionPlaceholder && window.argumentWorkspace && window.argumentWorkspace.conclusionAST_form) {
                    conclusionPlaceholder.innerHTML = '';
                    
                    if (window.argumentWorkspace.conclusionAST_form.type === 'operator' && 
                        window.argumentWorkspace.conclusionAST_form.operator === 'NOT') {
                        // NOT K case
                        const notSpan = document.createElement('span');
                        notSpan.textContent = 'NOT ';
                        notSpan.style.fontStyle = 'italic';
                        notSpan.style.color = '#dc3545';
                        conclusionPlaceholder.appendChild(notSpan);
                        
                        const kBubble = createEditablePropositionBubble('K', window.statementDefinitions && window.statementDefinitions.K);
                        conclusionPlaceholder.appendChild(kBubble);
                    } else if (window.argumentWorkspace.conclusionAST_form.type === 'proposition') {
                        // Just K case
                        const kBubble = createEditablePropositionBubble('K', window.statementDefinitions && window.statementDefinitions.K);
                        conclusionPlaceholder.appendChild(kBubble);
                    }
                }
                
                // Re-make elements draggable after a short delay
                setTimeout(() => {
                    const makeElementsDraggable = document.querySelector('#premisesContainer').__makeElementsDraggable;
                    if (makeElementsDraggable) {
                        makeElementsDraggable();
                    }
                }, 100);
            };
            
            // Helper function to create an editable proposition bubble
            window.createEditablePropositionBubble = function(letter, text) {
                const bubble = document.createElement('span');
                bubble.className = `palette-item proposition prop-${letter.toLowerCase()}`;
                bubble.style.display = 'inline-block';
                bubble.style.cursor = 'pointer';
                bubble.style.position = 'relative';
                bubble.title = 'Click to edit statement';
                
                // Add hover effect
                bubble.style.transition = 'transform 0.2s';
                bubble.onmouseover = function() {
                    this.style.transform = 'scale(1.1)';
                };
                bubble.onmouseout = function() {
                    this.style.transform = 'scale(1)';
                };
                
                if (text && text.trim() !== '') {
                    // Show text instead of letter
                    bubble.textContent = text.length > 30 ? text.substring(0, 30) + '...' : text;
                    bubble.style.padding = '8px 12px';
                    bubble.style.maxWidth = '200px';
                    bubble.style.whiteSpace = 'nowrap';
                    bubble.style.overflow = 'hidden';
                    bubble.style.textOverflow = 'ellipsis';
                    bubble.title = text; // Show full text on hover
                } else {
                    bubble.textContent = letter;
                }
                
                bubble.onclick = function(e) {
                    e.stopPropagation();
                    window.editPropositionText(letter);
                };
                
                return bubble;
            };
            
            // Simple function to make all propositions editable
            window.makePropositionsEditable = function() {
                // Prevent infinite loops
                if (window.isUpdatingPropositions) return;
                window.isUpdatingPropositions = true;
                
                // Find all proposition bubbles in premises
                const allPropositions = document.querySelectorAll('#premisesContainer .palette-item.proposition, #conclusionPlaceholder .palette-item.proposition');
                
                allPropositions.forEach(prop => {
                    // Skip if already processed
                    if (prop.dataset.editableProcessed === 'true') return;
                    
                    // Get the letter (first character or from the strong tag)
                    let letter = prop.textContent.trim();
                    if (letter.includes(':')) {
                        letter = letter.split(':')[0].trim();
                    }
                    if (letter.length === 1) {
                        // Update display if we have a definition
                        if (window.statementDefinitions && window.statementDefinitions[letter]) {
                            prop.classList.add('with-text');
                            prop.innerHTML = `<strong>${letter}:</strong> ${window.statementDefinitions[letter]}`;
                            prop.title = `${letter}: ${window.statementDefinitions[letter]}`;
                        }
                        
                        // Make it clickable
                        prop.style.cursor = letter === 'K' ? 'default' : 'pointer';
                        prop.onclick = null; // Clear any existing handler
                        prop.addEventListener('click', function(e) {
                            e.stopPropagation();
                            if (letter !== 'K') {
                                window.editPropositionText(letter);
                            }
                        });
                        
                        // Mark as processed
                        prop.dataset.editableProcessed = 'true';
                    }
                });
                
                window.isUpdatingPropositions = false;
            };
            
            // Remove the MutationObserver - we'll call makePropositionsEditable manually instead
            const defineStatementsNowButton = document.getElementById('defineStatementsNowButton');
            if (defineStatementsNowButton) {
                defineStatementsNowButton.addEventListener('click', function() {
                    console.log("Define statements button clicked");
                    showStatementDefinitionPanel();
                });
            }
            
            // Function to show statement definition panel
            window.showStatementDefinitionPanel = function() {
                console.log("showStatementDefinitionPanel called");
                const statementDefArea = document.getElementById('statementDefinitionArea');
                if (!statementDefArea) {
                    console.error("statementDefinitionArea not found");
                    return;
                }
                
                // Area is already visible, but we'll populate the input fields
                const container = document.getElementById('statementInputsContainer');
                if (!container) {
                    console.error("statementInputsContainer not found");
                    return;
                }
                
                // Clear existing content
                container.innerHTML = '';
                
                // Find all used letters in the argument
                const usedLetters = new Set();
                const premises = window.argumentWorkspace ? window.argumentWorkspace.premises : {};
                
                // Function to find letters in an AST
                function findLettersInAST(ast) {
                    if (!ast) return;
                    if (ast.type === 'proposition') {
                        usedLetters.add(ast.letter);
                    } else if (ast.type === 'operator') {
                        if (ast.operand) findLettersInAST(ast.operand);
                        if (ast.operands) {
                            ast.operands.forEach(op => findLettersInAST(op));
                        }
                    }
                }
                
                // Search all premises
                Object.values(premises).forEach(premise => {
                    findLettersInAST(premise);
                });
                
                // Always include K
                usedLetters.add('K');
                
                console.log("Used letters:", Array.from(usedLetters));
                
                // Create input fields for each used letter
                const sortedLetters = Array.from(usedLetters).sort();
                sortedLetters.forEach(letter => {
                    const div = document.createElement('div');
                    div.style.marginBottom = '15px';
                    
                    const label = document.createElement('label');
                    label.textContent = `Statement ${letter}: `;
                    label.style.fontWeight = 'bold';
                    label.style.display = 'block';
                    label.style.marginBottom = '5px';
                    
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.id = `statement-${letter}`;
                    input.style.width = '100%';
                    input.style.padding = '8px';
                    input.style.border = '1px solid #ccc';
                    input.style.borderRadius = '4px';
                    
                    // Pre-fill if we already have a definition
                    if (window.statementDefinitions && window.statementDefinitions[letter]) {
                        input.value = window.statementDefinitions[letter];
                        // Also update the local scope variable used by the event handler
                        if (!definitions) {
                            var definitions = {};
                        }
                        definitions[letter] = window.statementDefinitions[letter];
                    }
                    
                    // K should be read-only
                    if (letter === 'K') {
                        input.value = window.mainClaimText || '';
                        input.readOnly = true;
                        input.style.backgroundColor = '#f0f0f0';
                    }
                    
                    // Update statementDefinitions when user types
                    input.addEventListener('input', function() {
                        if (!window.statementDefinitions) {
                            window.statementDefinitions = {};
                        }
                        window.statementDefinitions[letter] = this.value.trim();
                        // Also update local definitions object
                        definitions[letter] = this.value.trim();
                        // Update all proposition displays
                        if (window.updateAllPropositionDisplays) {
                            window.updateAllPropositionDisplays();
                        }
                    });
                    
                    div.appendChild(label);
                    div.appendChild(input);
                    container.appendChild(div);
                });
                
                // Add instruction text at the bottom
                const instructionP = document.createElement('p');
                instructionP.style.color = '#666';
                instructionP.style.fontStyle = 'italic';
                instructionP.style.marginTop = '10px';
                instructionP.textContent = 'You can also click directly on any letter in your premises above to define it.';
                container.appendChild(instructionP);
                
                // Scroll to the definition area
                statementDefArea.scrollIntoView({ behavior: 'smooth', block: 'center' });
            };
            
            // Handle submit button for dynamic arguments
            const submitDynamicArgumentButton = document.getElementById('submitDynamicArgumentButton');
            console.log("Looking for submit button:", submitDynamicArgumentButton);
            if (submitDynamicArgumentButton) {
                console.log("Submit button found, adding click listener");
                submitDynamicArgumentButton.addEventListener('click', function() {
                    console.log("Submit dynamic argument clicked");
                    
                    // Collect all statement definitions
                    const inputs = document.querySelectorAll('#statementInputsContainer input');
                    let allFilled = true;
                    
                    // Make sure we have the global statementDefinitions object
                    if (!window.statementDefinitions) {
                        window.statementDefinitions = {};
                    }
                    
                    inputs.forEach(input => {
                        const letter = input.id.replace('statement-', '');
                        window.statementDefinitions[letter] = input.value.trim();
                        if (!window.statementDefinitions[letter] && letter !== 'K') {
                            allFilled = false;
                        }
                    });
                    
                    console.log("Global statementDefinitions:", window.statementDefinitions);
                    
                    if (!allFilled) {
                        alert('Please define all statements before submitting.');
                        return;
                    }
                    
                    // Prepare argument for submission
                    const argumentTitle = document.getElementById('dynamicArgumentTitle').value || 'Untitled Argument';
                    
                    // Get all premises ASTs for consistency check
                    const premises = window.argumentWorkspace ? window.argumentWorkspace.premises : {};
                    const premiseASTs = [];
                    Object.keys(premises).sort().forEach(premiseId => {
                        if (premises[premiseId] !== null && premises[premiseId] !== undefined) {
                            premiseASTs.push(premises[premiseId]);
                        }
                    });
                    
                    // Check validity and consistency before submission
                    const conclusionAST = window.argumentWorkspace && window.argumentWorkspace.conclusionAST_form 
                        ? window.argumentWorkspace.conclusionAST_form 
                        : { type: 'proposition', letter: 'K' };
                    
                    // Check consistency
                    const isConsistent = arePremisesConsistent(premiseASTs);
                    if (!isConsistent) {
                        alert('Cannot submit argument: The premises are INCONSISTENT (they cannot all be true at the same time). Please revise your argument to ensure consistency.');
                        return;
                    }
                    
                    // Check validity
                    const isValid = isArgumentFormValid(premiseASTs, conclusionAST);
                    if (!isValid) {
                        alert('Cannot submit argument: The argument form is INVALID. There exists a case where all premises are true but the conclusion is false. Please revise your argument to ensure validity.');
                        return;
                    }
                    
                    // Convert premises to readable format
                    const argumentLines = [];
                    const premiseURLs = {};
                    
                    // Function to convert AST to readable string - using global statementDefinitions
                    function astToReadableString(ast) {
                        if (!ast) return '[empty]';
                        if (ast.type === 'proposition') {
                            const text = window.statementDefinitions[ast.letter] || `[${ast.letter}]`;
                            return `<strong>${ast.letter}</strong>: ${text}`;
                        } else if (ast.type === 'operator') {
    if (ast.operator === 'NOT') {
        return `It is not the case that (${astToReadableString(ast.operand)})`;
    } else if (ast.operator === 'IFTHEN') {
                                return `IF (${astToReadableString(ast.operands[0])}) THEN (${astToReadableString(ast.operands[1])})`;
                            } else {
                                return `(${astToReadableString(ast.operands[0])}) ${ast.operator} (${astToReadableString(ast.operands[1])})`;
                            }
                        }
                        return '[unknown]';
                    }
                    
                    // Add each premise and collect URLs
                    Object.keys(premises).sort().forEach((premiseId, index) => {
                        if (premises[premiseId]) {
                            const line = astToReadableString(premises[premiseId]);
                            console.log(`Premise ${premiseId} converted to:`, line);
                            argumentLines.push(line);
                            
                            // Get the URL for this premise
                            const urlInput = document.getElementById(`premise-${premiseId}-url`);
                            if (urlInput && urlInput.value.trim()) {
                                let url = urlInput.value.trim();
                                
                                // Add protocol if missing
                                if (!url.match(/^https?:\/\//i)) {
                                    url = 'https://' + url;
                                }
                                
                                // Basic URL validation
                                try {
                                    new URL(url); // This will throw if invalid
                                    premiseURLs[index] = url;
                                    console.log(`Premise ${premiseId} has URL:`, url);
                                } catch (e) {
                                    console.error(`Invalid URL for premise ${premiseId}:`, url);
                                    alert(`Invalid URL for Premise ${premiseId}: ${urlInput.value.trim()}`);
                                }
                            }
                        }
                    });
                    
                    // Add conclusion
                    const conclusion = window.argumentWorkspace && window.argumentWorkspace.conclusionAST_form 
                        ? astToReadableString(window.argumentWorkspace.conclusionAST_form)
                        : `<strong>K</strong>: ${window.statementDefinitions.K || '[K]'}`;
                    console.log("Conclusion converted to:", conclusion);
                    argumentLines.push(`Therefore: ${conclusion}`);
                    
                    console.log("Final argumentLines being submitted:", argumentLines);
                    console.log("Premise URLs being submitted:", premiseURLs);
                    
                    // Submit to Firebase
                    const user = firebase.auth().currentUser;
                    if (!user) {
                        alert('You must be logged in to submit an argument.');
                        return;
                    }
                    
                    const argumentData = {
                        title: argumentTitle,
                        claimText: window.mainClaimText,
                        stanceText: selectedStanceForK,
                        argumentLines: argumentLines,
                        premiseURLs: premiseURLs,
                        endorsements: 0,
                        disagreements: 0,
                        endorsementPercentage: 0,
                        userId: user.uid,
                        userEmail: user.email,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    };
                    
                    db.collection('arguments').add(argumentData)
                        .then(() => {
                            alert('Argument submitted successfully!');
                            // Reset the form
                            location.reload();
                        })
                        .catch((error) => {
                            console.error('Error submitting argument:', error);
                            alert('Error submitting argument: ' + error.message);
                        });
                });
            }
            
            // Handle validation button
            const checkFormValidityButton = document.getElementById('checkFormValidityButton');
            if (checkFormValidityButton) {
                checkFormValidityButton.addEventListener('click', function() {
                    console.log("Validate button clicked");
                    
                    // Get all premises ASTs
                    const premiseASTs = [];
                    const premises = window.argumentWorkspace ? window.argumentWorkspace.premises : {};
                    
                    // Debug logging
                    console.log("All premises in workspace:", premises);
                    
                    Object.keys(premises).sort().forEach(premiseId => {
                        if (premises[premiseId] !== null && premises[premiseId] !== undefined) {
                            console.log(`Premise ${premiseId}:`, JSON.stringify(premises[premiseId]));
                            premiseASTs.push(premises[premiseId]);
                        } else {
                            console.log(`Premise ${premiseId}: null or undefined (skipping)`);
                        }
                    });
                    
                    // Get conclusion AST
                    const conclusionAST = window.argumentWorkspace && window.argumentWorkspace.conclusionAST_form 
                        ? window.argumentWorkspace.conclusionAST_form 
                        : { type: 'proposition', letter: 'K' };
                    
                    // Debug: Let's see exactly what we're validating
                    console.log("=== VALIDATION DEBUG ===");
                    console.log("Number of premises:", premiseASTs.length);
                    premiseASTs.forEach((premise, index) => {
                        console.log(`Premise ${index + 1}:`, JSON.stringify(premise, null, 2));
                    });
                    console.log("Conclusion:", JSON.stringify(conclusionAST, null, 2));
                    console.log("======================");
                    
                    // Check if we have the validation function
                    if (typeof isArgumentFormValid === 'function') {
                        // First check consistency
                        const isConsistent = arePremisesConsistent(premiseASTs);
                        
                        if (!isConsistent) {
                            const resultDiv = document.getElementById('validityResult');
                            if (resultDiv) {
                                resultDiv.innerHTML = '<span style="color: orange;">⚠ The premises are INCONSISTENT! They cannot all be true at the same time.</span>';
                                resultDiv.innerHTML += '<br><span style="color: #666; font-size: 14px;">An argument with inconsistent premises is vacuously valid but not useful.</span>';
                            }
                            return;
                        }
                        
                        const isValid = isArgumentFormValid(premiseASTs, conclusionAST);
                        
                        const resultDiv = document.getElementById('validityResult');
                        if (resultDiv) {
                            if (isValid) {
                                resultDiv.innerHTML = '<span style="color: green;">✓ This argument form is VALID!</span>';
                            } else {
                                resultDiv.innerHTML = '<span style="color: red;">✗ This argument form is INVALID. There exists a case where all premises are true but the conclusion is false.</span>';
                                
                                // Let's also show a counterexample
                                const usedLetters = new Set();
                                
                                // Find all letters in premises and conclusion
                                function findLetters(ast) {
                                    if (!ast) return;
                                    if (ast.type === 'proposition') {
                                        usedLetters.add(ast.letter);
                                    } else if (ast.type === 'operator') {
                                        if (ast.operand) findLetters(ast.operand);
                                        if (ast.operands) ast.operands.forEach(findLetters);
                                    }
                                }
                                
                                premiseASTs.forEach(findLetters);
                                findLetters(conclusionAST);
                                
                                // Try to find a counterexample
                                const letters = Array.from(usedLetters).sort();
                                const totalAssignments = Math.pow(2, letters.length);
                                
                                // Check if we have access to evaluateFormula
                                if (typeof evaluateFormula === 'function') {
                                    for (let i = 0; i < totalAssignments; i++) {
                                        const assignment = {};
                                        for (let j = 0; j < letters.length; j++) {
                                            assignment[letters[j]] = ((i >> j) & 1) === 1;
                                        }
                                        
                                        // Check if all premises are true
                                        let allPremisesTrue = premiseASTs.every(premise => 
                                            evaluateFormula(premise, assignment)
                                        );
                                        
                                        if (allPremisesTrue && !evaluateFormula(conclusionAST, assignment)) {
                                            // Found a counterexample
                                            const counterexampleText = letters.map(letter => 
                                                `${letter}=${assignment[letter] ? 'true' : 'false'}`
                                            ).join(', ');
                                            
                                            resultDiv.innerHTML += `<br><span style="color: #666; font-size: 14px;">Counterexample: ${counterexampleText}</span>`;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        alert('Validation engine not loaded properly.');
                    }
                });
            }
            
            // Add functionality to remove premises
            const removePremiseButton = document.getElementById('removePremiseButton');
            if (removePremiseButton) {
                removePremiseButton.addEventListener('click', function() {
                    const premisesContainer = document.getElementById('premisesContainer');
                    const allPremiseSlots = premisesContainer.querySelectorAll('.premise-slot');
                    
                    if (allPremiseSlots.length <= 2) {
                        alert('You must have at least 2 premises.');
                        return;
                    }
                    
                    // Remove the last premise
                    const lastPremiseNum = allPremiseSlots.length;
                    const lastPremiseSlot = document.getElementById(`premise-${lastPremiseNum}-slot-container`);
                    
                    if (lastPremiseSlot) {
                        lastPremiseSlot.remove();
                        // Also remove from argumentWorkspace
                        if (window.argumentWorkspace && window.argumentWorkspace.premises) {
                            delete window.argumentWorkspace.premises[lastPremiseNum.toString()];
                        }
                    }
                });
            }
            const premisesContainer = document.getElementById('premisesContainer');
            if (premisesContainer) {
                const makeElementsDraggable = function() {
                    const formulaElements = premisesContainer.querySelectorAll('.formula-element-wrapper');
                    console.log(`Making ${formulaElements.length} formula elements draggable`);
                    
                    formulaElements.forEach(element => {
                        if (!element.hasAttribute('draggable')) {
                            element.setAttribute('draggable', 'true');
                            element.style.cursor = 'move';
                            
                            element.addEventListener('dragstart', function(e) {
                                e.stopPropagation();
                                this.classList.add('dragging');
                                this.style.opacity = '0.5';
                                
                                // Store the element info in dataTransfer
                                const premiseId = this.dataset.premiseId || '';
                                const path = this.dataset.path || '';
                                const dragData = {
                                    type: 'formula-element',
                                    premiseId: premiseId,
                                    path: path
                                };
                                
                                console.log("Dragging element:", dragData);
                                console.log("Element dataset:", this.dataset);
                                e.dataTransfer.setData('application/json', JSON.stringify(dragData));
                                e.dataTransfer.setData('text/plain', `${premiseId}|${path}`); // Backup format
                                e.dataTransfer.effectAllowed = 'move';
                                
                                // Store reference globally as backup
                                window.currentlyDraggedElement = this;
                                
                                // Also click to select it
                                this.click();
                            });
                            
                            element.addEventListener('dragend', function(e) {
                                this.classList.remove('dragging');
                                this.style.opacity = '';
                            });
                        }
                    });
                };
                
                // Store the function reference on the container element
                premisesContainer.__makeElementsDraggable = makeElementsDraggable;
                
                // Initial setup
                setTimeout(makeElementsDraggable, 100);
                
                // Watch for changes
                const observer = new MutationObserver(function(mutations) {
                    makeElementsDraggable();
                });
                
                observer.observe(premisesContainer, {
                    childList: true,
                    subtree: true
                });
            }
        });
    </script>

    <script>
        console.log("Script 2: Starting main script");
        
        // Complete claims data
const claimsByCategory = {
    "Everyday Life & Fun": {
        "Food & Drink Debates": [
            { value: 'fun_food_001', text: 'Pineapple belongs on pizza.' },
            { value: 'fun_food_002', text: 'A hot dog is a sandwich.' },
            { value: 'fun_food_003', text: 'Cereal is a soup.' },
            { value: 'fun_food_004', text: 'Ketchup belongs on mac and cheese.' },
            { value: 'fun_food_005', text: 'Coffee is better than tea.' }
        ],
        "Household Debates": [
            { value: 'fun_house_001', text: 'Toilet paper should hang with the loose end over the roll.' },
            { value: 'fun_house_002', text: 'Shoes should be removed when entering a home.' },
            { value: 'fun_house_003', text: 'The toilet seat should be left down after use.' },
            { value: 'fun_house_004', text: 'Dishes should be rinsed before going in the dishwasher.' }
        ],
        "Lifestyle Preferences": [
            { value: 'fun_life_001', text: 'Morning people are more productive than night owls.' },
            { value: 'fun_life_002', text: 'Cats make better pets than dogs.' },
            { value: 'fun_life_003', text: 'Books are better than their movie adaptations.' },
            { value: 'fun_life_004', text: 'Summer is the best season.' }
        ]
    },
    "Sports & Entertainment": {
        "GOAT Debates": [
            { value: 'sport_goat_001', text: 'Michael Jordan is the greatest basketball player of all time.' },
            { value: 'sport_goat_002', text: 'Tom Brady is the greatest NFL quarterback of all time.' },
            { value: 'sport_goat_003', text: 'Serena Williams is the greatest tennis player of all time.' },
            { value: 'sport_goat_004', text: 'Wayne Gretzky is the greatest hockey player of all time.' }
        ],
        "Entertainment": [
            { value: 'ent_tv_001', text: 'Die Hard is a Christmas movie.' },
            { value: 'ent_tv_002', text: 'The book is always better than the movie.' },
            { value: 'ent_tv_003', text: 'Streaming services are better than cable TV.' },
            { value: 'ent_tv_004', text: 'Physical books are better than e-readers.' }
        ],
        "Gaming": [
            { value: 'game_001', text: 'PC gaming is superior to console gaming.' },
            { value: 'game_002', text: 'Video games are a legitimate form of art.' },
            { value: 'game_003', text: 'Mobile gaming is real gaming.' }
        ]
    },
    "Technology & Modern Life": {
        "Social Media & Communication": [
            { value: 'tech_social_001', text: 'Text messages are better than phone calls.' },
            { value: 'tech_social_002', text: 'Social media does more harm than good.' },
            { value: 'tech_social_003', text: 'People should use their real names online.' }
        ],
        "Work & Productivity": [
            { value: 'tech_work_001', text: 'Working from home is more productive than working in an office.' },
            { value: 'tech_work_002', text: 'A four-day work week would increase productivity.' },
            { value: 'tech_work_003', text: 'Multitasking makes people less efficient.' }
        ]
    },
    "Education & Learning": {
        "School Debates": [
            { value: 'edu_school_001', text: 'Schools should start later in the morning.' },
            { value: 'edu_school_002', text: 'Homework is beneficial for student learning.' },
            { value: 'edu_school_003', text: 'Year-round schooling is better than summer breaks.' },
            { value: 'edu_school_004', text: 'Cursive writing should still be taught in schools.' }
        ],
        "Learning Methods": [
            { value: 'edu_learn_001', text: 'Online learning is as effective as in-person learning.' },
            { value: 'edu_learn_002', text: 'Students learn better with technology in the classroom.' },
            { value: 'edu_learn_003', text: 'Group projects are valuable learning experiences.' }
        ]
    },
    "Advanced Topics": {
        "Note": [
            { value: 'adv_note_001', text: 'More serious topics will be added as the community grows!' }
        ]
    }
};
        
        console.log("Script 2: Claims data defined");

        // Function to set up the dynamic builder
        function setupDynamicBuilderExternal(claimText, stance, claimLetter) {
            console.log("LOG: setupDynamicBuilderExternal called with:", claimText, stance, claimLetter);
            
            // Store the claim text globally for later use
            window.mainClaimText = claimText;
            if (!window.statementDefinitions) {
                window.statementDefinitions = {};
            }
            window.statementDefinitions.K = claimText;
            
            // Initialize argumentWorkspace if it doesn't exist
            if (!window.argumentWorkspace) {
                window.argumentWorkspace = {
                    premises: {},
                    conclusionAST_form: null
                };
            }
            
            // Set the conclusion AST based on stance
            if (stance === 'Against') {
                window.argumentWorkspace.conclusionAST_form = {
                    type: 'operator',
                    operator: 'NOT',
                    operand: { type: 'proposition', letter: 'K', colorClass: 'prop-k' }
                };
            } else {
                window.argumentWorkspace.conclusionAST_form = {
                    type: 'proposition',
                    letter: 'K',
                    colorClass: 'prop-k'
                };
            }
            
            // Update the conclusion placeholder
            const conclusionPlaceholder = document.getElementById('conclusionPlaceholder');
            if (conclusionPlaceholder) {
                conclusionPlaceholder.innerHTML = ''; // Clear existing content
                
                if (stance === 'Against') {
                    // Create NOT text
                    const notSpan = document.createElement('span');
                    notSpan.textContent = 'NOT ';
                    notSpan.style.fontStyle = 'italic';
                    notSpan.style.color = '#dc3545';
                    conclusionPlaceholder.appendChild(notSpan);
                    
                    // Create K bubble with text
                    const kBubble = window.createEditablePropositionBubble ? 
                        window.createEditablePropositionBubble('K', claimText) : 
                        document.createElement('span');
                    if (!window.createEditablePropositionBubble) {
                        kBubble.className = 'palette-item proposition prop-k';
                        kBubble.textContent = 'K';
                        kBubble.style.display = 'inline-block';
                        kBubble.style.cursor = 'default';
                    }
                    conclusionPlaceholder.appendChild(kBubble);
                } else {
                    // Just create K bubble with text
                    const kBubble = window.createEditablePropositionBubble ? 
                        window.createEditablePropositionBubble('K', claimText) : 
                        document.createElement('span');
                    if (!window.createEditablePropositionBubble) {
                        kBubble.className = 'palette-item proposition prop-k';
                        kBubble.textContent = 'K';
                        kBubble.style.display = 'inline-block';
                        kBubble.style.cursor = 'default';
                    }
                    conclusionPlaceholder.appendChild(kBubble);
                }
            }
            
            // Update the display elements
            const displayMainClaimK = document.getElementById('displayMainClaimK');
            if (displayMainClaimK) {
                displayMainClaimK.textContent = claimText;
            }
            
            const displayStanceOnK = document.getElementById('displayStanceOnK');
            if (displayStanceOnK) {
                displayStanceOnK.textContent = stance.toUpperCase();
            }
            
            console.log("LOG: Dynamic builder setup completed");
            
            // Make sure statement definition area is visible
            const statementDefArea = document.getElementById('statementDefinitionArea');
            if (statementDefArea) {
                statementDefArea.style.display = 'block';
            }
            
            // Start making propositions editable
            setTimeout(() => {
                if (window.makePropositionsEditable) {
                    window.makePropositionsEditable();
                }
            }, 100);
        }

        // All the main functions
        function initializeAndShowDynamicBuilder() {
            const claimSelect = document.getElementById('claimSelect');
            const stanceSelect = document.getElementById('stanceSelect');

            if (!claimSelect || claimSelect.value === "") {
                alert("Please select the Main Claim (K) you will argue about from the dropdowns.");
                if (claimSelect) claimSelect.focus(); 
                return;
            }
            if (!stanceSelect || stanceSelect.value === "") {
                alert("Please select your Stance on this claim from the dropdowns.");
                if (stanceSelect) stanceSelect.focus(); 
                return;
            }

            selectedClaimTextForK = claimSelect.options[claimSelect.selectedIndex].text;
            selectedStanceForK = stanceSelect.value; 

            console.log(`LOG: Initializing dynamic builder. Claim (K): "${selectedClaimTextForK}", Stance: ${selectedStanceForK}`);

            const displayMainClaimKEl = document.getElementById('displayMainClaimK');
            if (displayMainClaimKEl) displayMainClaimKEl.textContent = selectedClaimTextForK;
            const displayStanceOnKEl = document.getElementById('displayStanceOnK');
            if (displayStanceOnKEl) displayStanceOnKEl.textContent = selectedStanceForK.toUpperCase();

            if (typeof setupDynamicBuilderExternal === "function") {
                setupDynamicBuilderExternal(selectedClaimTextForK, selectedStanceForK, 'K'); 
                
                const claimSetupForm = document.getElementById('claimSetupForm');
                if(claimSetupForm) claimSetupForm.style.display = 'none';

                const dynamicBuilderSection = document.getElementById('dynamicArgumentBuilder');
                if (dynamicBuilderSection) dynamicBuilderSection.style.display = 'block'; 
                
                console.log("LOG: Dynamic builder setup initiated and should be visible.");
            } else {
                console.error("LOG: CRITICAL - setupDynamicBuilderExternal function not found!");
                alert("Error: Could not initialize the dynamic argument builder.");
            }
        }

        // Function to parse and recreate proposition bubbles in displayed arguments
function formatArgumentLine(line) {
    // Create a container for the formatted line
    const container = document.createElement('div');
    container.style.display = 'block';
    container.style.width = '100%';
    container.style.lineHeight = '2';
    
    // Helper function to create a proposition bubble - mobile-friendly version
    function createBubble(letter, text) {
        const bubble = document.createElement('span');
        bubble.className = `palette-item proposition prop-${letter.toLowerCase()}`;
        bubble.style.display = 'inline-block';
        bubble.style.margin = '2px 4px';
        bubble.style.cursor = 'default';
        bubble.style.verticalAlign = 'middle';
        
        // Always show full text if available
        if (text && text.trim() !== '') {
            bubble.innerHTML = `<strong>${letter}:</strong> ${text}`;
            bubble.title = `${letter}: ${text}`;
            // Mobile-friendly styling
            bubble.style.padding = '6px 12px';
            bubble.style.fontSize = '0.875rem';
            bubble.style.fontWeight = '600';
            bubble.style.textTransform = 'none';
            bubble.style.letterSpacing = 'normal';
            bubble.style.whiteSpace = 'normal';
            bubble.style.wordWrap = 'break-word';
            bubble.style.wordBreak = 'normal';
            bubble.style.hyphens = 'auto';
            bubble.style.maxWidth = '100%';
            bubble.style.lineHeight = '1.4';
            
            // Adjust for mobile
            if (window.innerWidth <= 768) {
                bubble.style.fontSize = '0.8rem';
                bubble.style.padding = '4px 8px';
                bubble.style.display = 'inline-block';
                bubble.style.maxWidth = 'calc(100% - 8px)';
            }
        } else {
            // No text available - just show letter
            bubble.textContent = letter;
            bubble.style.padding = '0.5rem 1rem';
        }
        
        return bubble;
    }
    
    // Helper function to create a proposition bubble - ALWAYS show full text
    function createBubble(letter, text) {
        const bubble = document.createElement('span');
        bubble.className = `palette-item proposition prop-${letter.toLowerCase()}`;
        bubble.style.display = 'inline-block';
        bubble.style.margin = '0 4px';
        bubble.style.cursor = 'default';
        bubble.style.verticalAlign = 'middle';
        
        // Always show full text if available
        if (text && text.trim() !== '') {
            bubble.innerHTML = `<strong>${letter}:</strong> ${text}`;
            bubble.title = `${letter}: ${text}`;
            // Styling for text bubbles with proper wrapping
            bubble.style.padding = '8px 16px';
            bubble.style.fontSize = '0.875rem';
            bubble.style.fontWeight = '600';
            bubble.style.textTransform = 'none';
            bubble.style.letterSpacing = 'normal';
            bubble.style.whiteSpace = 'normal';  // Allow text wrapping
            bubble.style.wordWrap = 'break-word';  // Break long words if needed
            bubble.style.wordBreak = 'break-word';  // Ensure words break properly
            bubble.style.maxWidth = '600px';  // Increased width for better readability
            bubble.style.display = 'inline-block';
            bubble.style.lineHeight = '1.4';  // Better line spacing for wrapped text
            bubble.style.verticalAlign = 'top';  // Align wrapped bubbles properly
        } else {
            // No text available - just show letter
            bubble.textContent = letter;
            bubble.style.padding = '0.5rem 1rem';
        }
        
        return bubble;
    }
    
    // Helper function to create operator spans
function createOperator(text, isNot = false) {
    const span = document.createElement('span');
    span.style.fontWeight = '600';
    span.style.color = '#4a5568';
    span.style.margin = isNot ? '0 4px' : '0 8px';
    span.style.fontStyle = 'italic';
    span.style.whiteSpace = 'nowrap';
    
    span.textContent = text;
    return span;
}
    
    // Extract all proposition definitions first
    const definitions = {};
    const defPattern = /<strong>([A-K])<\/strong>:\s*([^<]+?)(?=\s*(?:<strong>|IF|THEN|AND|OR|NOT|\(|\)|Therefore:|$))/g;
    let match;
    while ((match = defPattern.exec(line)) !== null) {
        definitions[match[1]] = match[2].trim();
    }
    
    // Special handling for K - it might come from the main claim
    if (!definitions['K'] && window.mainClaimText) {
        definitions['K'] = window.mainClaimText;
    }
    
    // Function to recursively parse and build the visual structure
    function parseExpression(expr) {
        expr = expr.trim();
        
        // First, check if it's just a letter (with or without parentheses)
        // This handles: A, (A), K, (K), etc.
        const simpleLetterMatch = expr.match(/^\(?([A-K])\)?$/);
        if (simpleLetterMatch) {
            return createBubble(simpleLetterMatch[1], definitions[simpleLetterMatch[1]]);
        }
        
        // Handle NOT - now checking for both "NOT" and "It is not the case that"
if (expr.startsWith('NOT') || expr.startsWith('It is not the case that')) {
    const group = document.createElement('span');
    group.style.display = 'inline-block';
    group.style.alignItems = 'center';
    group.style.border = '1px solid #d0d0d0';
    group.style.padding = '4px 8px';
    group.style.borderRadius = '6px';
    group.style.backgroundColor = '#f8f9fa';
    group.style.margin = '0 2px';
    
    group.appendChild(createOperator('It is not the case that', true));
    
    // Find what NOT applies to
    let remaining;
    if (expr.startsWith('NOT')) {
        remaining = expr.substring(3).trim();
    } else {
        remaining = expr.substring('It is not the case that'.length).trim();
    }
    group.appendChild(parseExpression(remaining));
    return group;
}
        
        // Handle IF...THEN
        if (expr.startsWith('IF')) {
            const group = document.createElement('span');
            group.style.display = 'inline-block';
            group.style.alignItems = 'center';
            group.style.border = '1px solid #d0d0d0';
            group.style.padding = '4px 8px';
            group.style.borderRadius = '6px';
            group.style.backgroundColor = '#f8f9fa';
            group.style.margin = '0 2px';
            
            // Parse IF part
            group.appendChild(createOperator('IF'));
            
            const thenIndex = expr.indexOf('THEN');
            if (thenIndex > 0) {
                let ifPart = expr.substring(2, thenIndex).trim();
                group.appendChild(parseExpression(ifPart));
                
                group.appendChild(createOperator('THEN'));
                
                let thenPart = expr.substring(thenIndex + 4).trim();
                group.appendChild(parseExpression(thenPart));
            }
            
            return group;
        }
        
        // Handle expressions with AND/OR (with or without outer parentheses)
        // First remove outer parentheses if they exist
        let innerExpr = expr;
        if (expr.startsWith('(') && expr.endsWith(')')) {
            // Check if these are the outermost parentheses
            let depth = 0;
            let isOuterParen = true;
            for (let i = 0; i < expr.length - 1; i++) {
                if (expr[i] === '(') depth++;
                if (expr[i] === ')') depth--;
                if (depth === 0) {
                    isOuterParen = false;
                    break;
                }
            }
            if (isOuterParen) {
                innerExpr = expr.substring(1, expr.length - 1);
            }
        }
        
        // Look for AND or OR at the top level
        let depth = 0;
        let operatorPos = -1;
        let operator = '';
        
        for (let i = 0; i < innerExpr.length; i++) {
            if (innerExpr[i] === '(') depth++;
            if (innerExpr[i] === ')') depth--;
            
            if (depth === 0) {
                if (innerExpr.substring(i).startsWith(' AND ')) {
                    operatorPos = i;
                    operator = 'AND';
                    break;
                }
                if (innerExpr.substring(i).startsWith(' OR ')) {
                    operatorPos = i;
                    operator = 'OR';
                    break;
                }
            }
        }
        
        if (operatorPos > -1 && operator) {
            const group = document.createElement('span');
            group.style.display = 'inline-block';
            group.style.alignItems = 'center';
            group.style.border = '1px solid #d0d0d0';
            group.style.padding = '4px 8px';
            group.style.borderRadius = '6px';
            group.style.backgroundColor = '#f8f9fa';
            group.style.margin = '0 2px';
            
            const leftPart = innerExpr.substring(0, operatorPos).trim();
            const rightPart = innerExpr.substring(operatorPos + operator.length + 2).trim();
            
            group.appendChild(parseExpression(leftPart));
group.appendChild(createOperator(operator));
group.appendChild(parseExpression(rightPart));
            
            return group;
        }
        
        // If we got here and the expression is still in parentheses, remove them and try again
        if (expr !== innerExpr) {
            return parseExpression(innerExpr);
        }
        
        // Fallback - return as text
        const span = document.createElement('span');
        span.textContent = expr;
        return span;
    }
    
    // Main line processing
    // Check if it's a conclusion line
    if (line.includes('Therefore:')) {
    const thereforeSpan = document.createElement('span');
    thereforeSpan.style.fontWeight = 'bold';
    thereforeSpan.style.marginRight = '8px';
    thereforeSpan.style.color = '#48bb78';  // Green color for conclusion
    thereforeSpan.style.fontSize = '1.1rem';
    thereforeSpan.textContent = 'Therefore: ';
        container.appendChild(thereforeSpan);
        
        // Extract the conclusion part
        const conclusionPart = line.substring(line.indexOf('Therefore:') + 10);
        
        // Remove HTML tags to get clean conclusion
        const cleanConclusion = conclusionPart.replace(/<strong>([A-K])<\/strong>:\s*[^<]+?(?=\s*(?:<strong>|IF|THEN|AND|OR|NOT|\(|\)|$))/g, '$1').trim();
        
        // Parse the conclusion
        container.appendChild(parseExpression(cleanConclusion));
        
        return container;
    }
    
    // For regular premises
    // Check if line contains logical operators
    const hasOperators = /\b(IF|THEN|AND|OR|NOT)\b/.test(line);
    
    if (!hasOperators) {
        // Simple proposition
        const simpleMatch = line.match(/<strong>([A-K])<\/strong>:\s*(.+)$/);
        if (simpleMatch) {
            container.appendChild(createBubble(simpleMatch[1], simpleMatch[2]));
            return container;
        }
    }
    
    // Complex expression - parse it
    const cleanFormula = line.replace(/<strong>([A-K])<\/strong>:\s*[^<]+?(?=\s*(?:<strong>|IF|THEN|AND|OR|NOT|\(|\)|$))/g, '$1');
    container.appendChild(parseExpression(cleanFormula));
    
    return container;
}

        function displayArguments(showNext = false) {
            const argumentsList = document.getElementById('argumentsList');
            if (!argumentsList) return;
            
            // Always clear the list to show only one argument at a time
            argumentsList.innerHTML = '';

            const rankingMethod = document.getElementById('rankingSelect').value;
            const claimFilter = document.getElementById('filterClaimSelect').value;
            const stanceFilter = document.getElementById('filterStanceSelect').value;
            const user = firebase.auth().currentUser;

            let query = db.collection('arguments');

            // Apply filters
            if (claimFilter) {
                query = query.where('claimText', '==', claimFilter);
            }
            if (stanceFilter) {
                query = query.where('stanceText', '==', stanceFilter);
            }

            // For random mode, we'll fetch all and select randomly
            if (rankingMethod === 'random') {
                query.get().then((querySnapshot) => {
                    if (querySnapshot.empty) {
                        argumentsList.innerHTML = '<p style="text-align: center; color: #666;">No arguments found matching your filters.</p>';
                        document.getElementById('nextButton').style.display = 'none';
                        return;
                    }
                    
                    // Convert to array for random selection
                    const allArguments = [];
                    querySnapshot.forEach((doc) => {
                        const argumentObj = doc.data();
                        argumentObj.id = doc.id;
                        allArguments.push(argumentObj);
                    });
                    
                    // Store in window for next random selection
                    if (!showNext) {
                        window.availableArguments = [...allArguments];
                        window.shownArgumentIds = new Set();
                        argumentsList.innerHTML = '';
                    }
                    
                    // Filter out already shown arguments
                    const remainingArguments = window.availableArguments.filter(arg => !window.shownArgumentIds.has(arg.id));
                    
                    if (remainingArguments.length === 0) {
                        // Reset if all arguments have been shown
                        window.shownArgumentIds.clear();
                        window.availableArguments = [...allArguments];
                    }
                    
                    // Select random argument from remaining
                    const finalPool = window.shownArgumentIds.size === 0 ? window.availableArguments : remainingArguments;
                    const randomIndex = Math.floor(Math.random() * finalPool.length);
                    const selectedArgument = finalPool[randomIndex];
                    
                    if (selectedArgument) {
                        window.shownArgumentIds.add(selectedArgument.id);
                        renderArgument(selectedArgument, user, argumentsList);
                        
                        // Show "Show Another" button
                        document.getElementById('nextButton').style.display = 'inline-block';
                        document.getElementById('filterButton').textContent = 'Reset';
                    }
                }).catch((error) => {
                    console.error("Error getting documents: ", error);
                    argumentsList.innerHTML = '<p style="text-align: center; color: #dc3545;">Error loading arguments. Please try again.</p>';
                });
            } else {
                // Original ordering logic for non-random modes
                document.getElementById('nextButton').style.display = 'none';
                document.getElementById('filterButton').textContent = 'Show Arguments';
                
                // Add ordering
                if (rankingMethod === 'mostEndorsed') {
                    query = query.orderBy('endorsements', 'desc');
                } else if (rankingMethod === 'highestPercentage') {
                    query = query.orderBy('endorsementPercentage', 'desc');
                } else { // mostRecent
                    query = query.orderBy('createdAt', 'desc');
                }

                // Show all arguments for non-random modes
                query.limit(10).get().then((querySnapshot) => {
                    if (querySnapshot.empty) {
                        argumentsList.innerHTML = '<p style="text-align: center; color: #666;">No arguments found matching your filters.</p>';
                        return;
                    }
                    
                    querySnapshot.forEach((doc) => {
                        const argumentObj = doc.data();
                        argumentObj.id = doc.id;
                        renderArgument(argumentObj, user, argumentsList);
                    });
                }).catch((error) => {
                    console.error("Error getting documents: ", error);
                    argumentsList.innerHTML = '<p style="text-align: center; color: #dc3545;">Error loading arguments. Please try again.</p>';
                });
            }
        }

// Extract the argument rendering logic into a separate function
        function renderArgument(argumentObj, user, container) {
            // Render argument
            const argumentDiv = document.createElement('div');
            argumentDiv.className = 'argument';
            argumentDiv.dataset.id = argumentObj.id;

            const argumentHeader = document.createElement('div');
            argumentHeader.className = 'argument-header';

            const stanceIcon = document.createElement('i');
            stanceIcon.className = 'argument-icon ' + (argumentObj.stanceText === 'For' ? 'fas fa-thumbs-up' : 'fas fa-thumbs-down');

            const argumentTitle = document.createElement('h3');
            argumentTitle.className = 'argument-title';
            argumentTitle.textContent = argumentObj.title;

            argumentHeader.appendChild(stanceIcon);
            argumentHeader.appendChild(argumentTitle);

            const claimElement = document.createElement('p');
            claimElement.innerHTML = `<strong>Claim (${argumentObj.stanceText}):</strong> ${argumentObj.claimText}`;
            claimElement.style.marginTop = '15px';
            claimElement.style.fontSize = '20px';
            claimElement.style.color = '#555';

            const argumentContentDiv = document.createElement('div');
            argumentContentDiv.className = 'argument-content';

            const ol = document.createElement('ol');

            argumentObj.argumentLines.forEach((line, index) => {
                const li = document.createElement('li');

                const premiseText = document.createElement('span');
                premiseText.className = 'premise-text';
                // Use the formatter to recreate bubbles
                const formattedContent = formatArgumentLine(line);
                premiseText.appendChild(formattedContent);

                li.appendChild(premiseText);

                // Add URL next to the premise if available
                if (argumentObj.premiseURLs && argumentObj.premiseURLs[index]) {
                    const urlLink = document.createElement('a');
                    urlLink.href = argumentObj.premiseURLs[index];
                    urlLink.target = '_blank';
                    urlLink.rel = 'noopener noreferrer';
                    urlLink.textContent = 'View Evidence';
                    urlLink.className = 'premise-url';
                    urlLink.style.marginLeft = '10px';
                    urlLink.style.color = '#007bff';
                    urlLink.style.textDecoration = 'underline';
                    li.appendChild(urlLink);
                }

                // Add buttons
                if (index < argumentObj.argumentLines.length - 1) {
                    const voteContainer = document.createElement('div');
                    voteContainer.className = 'premise-vote-container';
                    
                    const disagreeButton = document.createElement('button');
                    disagreeButton.textContent = 'Disagree with this premise';
                    disagreeButton.className = 'disagree-premise-button';
                    disagreeButton.dataset.argumentId = argumentObj.id;
                    disagreeButton.dataset.premiseIndex = index;
                    
                    // Always set initial onclick to check authentication
                    disagreeButton.onclick = function() {
                        const currentUser = firebase.auth().currentUser;
                        if (!currentUser) {
                            alert('You must be logged in to disagree with a premise.');
                            return;
                        }
                        updateDisagreement(this.dataset.argumentId, parseInt(this.dataset.premiseIndex));
                    };
                    
                    // If user is logged in, check their voting status
                    if (user) {
                        Promise.all([
                            checkUserEndorsement(argumentObj.id),
                            checkUserDisagreement(argumentObj.id, index)
                        ]).then(([hasEndorsed, hasDisagreed]) => {
                            if (hasEndorsed) {
                                // User endorsed, so disable disagree button
                                disagreeButton.textContent = 'Already endorsed conclusion';
                                disagreeButton.disabled = true;
                                disagreeButton.style.backgroundColor = '#6c757d';
                                disagreeButton.style.cursor = 'not-allowed';
                                disagreeButton.onclick = null;
                            } else if (hasDisagreed) {
                                // User already disagreed with this premise
                                disagreeButton.textContent = 'Remove Disagreement';
                                disagreeButton.style.backgroundColor = '#6c757d';
                                disagreeButton.onclick = function() {
                                    removeDisagreement(this.dataset.argumentId, parseInt(this.dataset.premiseIndex));
                                };
                            }
                        });
                    }
                    
                    voteContainer.appendChild(disagreeButton);
                    li.appendChild(voteContainer);
                } else {
                    const endorseButton = document.createElement('button');
                    endorseButton.textContent = 'Endorse Conclusion';
                    endorseButton.className = 'endorse-conclusion-button';
                    endorseButton.dataset.argumentId = argumentObj.id;
                    
                    // Always set initial onclick to check authentication
                    endorseButton.onclick = function() {
                        const currentUser = firebase.auth().currentUser;
                        if (!currentUser) {
                            alert('You must be logged in to endorse the conclusion.');
                            return;
                        }
                        updateEndorsement(this.dataset.argumentId);
                    };
                    
                    // If user is logged in, check their voting status
                    if (user) {
                        Promise.all([
                            checkUserEndorsement(argumentObj.id),
                            checkUserAnyDisagreement(argumentObj.id)
                        ]).then(([hasEndorsed, hasDisagreed]) => {
                            if (hasDisagreed) {
                                // User disagreed with a premise, so disable endorse button
                                endorseButton.textContent = 'Already disagreed with premise';
                                endorseButton.disabled = true;
                                endorseButton.style.backgroundColor = '#6c757d';
                                endorseButton.style.cursor = 'not-allowed';
                                endorseButton.onclick = null;
                            } else if (hasEndorsed) {
                                // User already endorsed
                                endorseButton.textContent = 'Remove Endorsement';
                                endorseButton.style.backgroundColor = '#6c757d';
                                endorseButton.onclick = function() {
                                    removeEndorsement(this.dataset.argumentId);
                                };
                            }
                        });
                    }
                    
                    li.appendChild(document.createElement('br'));
                    li.appendChild(endorseButton);
                }

                ol.appendChild(li);
            });

            argumentContentDiv.appendChild(ol);

            // Display endorsement stats
            const endorsementStats = document.createElement('div');
            endorsementStats.className = 'endorsement-stats';
            endorsementStats.textContent = `Endorsements: ${argumentObj.endorsements || 0} | Disagreements: ${argumentObj.disagreements || 0} | Endorsement Percentage: ${argumentObj.endorsementPercentage ? argumentObj.endorsementPercentage.toFixed(2) : 0}%`;

            argumentDiv.appendChild(argumentHeader);
            argumentDiv.appendChild(claimElement);
            argumentDiv.appendChild(argumentContentDiv);
            argumentDiv.appendChild(endorsementStats);

            container.appendChild(argumentDiv);
        }
        function renderArgument(argumentObj, user, container) {
            // Render argument
            const argumentDiv = document.createElement('div');
            argumentDiv.className = 'argument';
            argumentDiv.dataset.id = argumentObj.id;

            const argumentHeader = document.createElement('div');
            argumentHeader.className = 'argument-header';

            const stanceIcon = document.createElement('i');
            stanceIcon.className = 'argument-icon ' + (argumentObj.stanceText === 'For' ? 'fas fa-thumbs-up' : 'fas fa-thumbs-down');

            const argumentTitle = document.createElement('h3');
            argumentTitle.className = 'argument-title';
            argumentTitle.textContent = argumentObj.title;

            argumentHeader.appendChild(stanceIcon);
            argumentHeader.appendChild(argumentTitle);

            const claimElement = document.createElement('p');
            claimElement.innerHTML = `<strong>Claim (${argumentObj.stanceText}):</strong> ${argumentObj.claimText}`;
            claimElement.style.marginTop = '15px';
            claimElement.style.fontSize = '20px';
            claimElement.style.color = '#555';

            const argumentContentDiv = document.createElement('div');
            argumentContentDiv.className = 'argument-content';

            const ol = document.createElement('ol');

            argumentObj.argumentLines.forEach((line, index) => {
                const li = document.createElement('li');

                const premiseText = document.createElement('span');
                premiseText.className = 'premise-text';
                // Use the formatter to recreate bubbles
                const formattedContent = formatArgumentLine(line);
                premiseText.appendChild(formattedContent);

                li.appendChild(premiseText);

                // Add URL next to the premise if available
                if (argumentObj.premiseURLs && argumentObj.premiseURLs[index]) {
                    const urlLink = document.createElement('a');
                    urlLink.href = argumentObj.premiseURLs[index];
                    urlLink.target = '_blank';
                    urlLink.rel = 'noopener noreferrer';
                    urlLink.textContent = 'View Evidence';
                    urlLink.className = 'premise-url';
                    urlLink.style.marginLeft = '10px';
                    urlLink.style.color = '#007bff';
                    urlLink.style.textDecoration = 'underline';
                    li.appendChild(urlLink);
                }

                // Add buttons
                if (index < argumentObj.argumentLines.length - 1) {
                    const voteContainer = document.createElement('div');
                    voteContainer.className = 'premise-vote-container';
                    
                    const disagreeButton = document.createElement('button');
                    disagreeButton.textContent = 'Disagree with this premise';
                    disagreeButton.className = 'disagree-premise-button';
                    disagreeButton.dataset.argumentId = argumentObj.id;
                    disagreeButton.dataset.premiseIndex = index;
                    
                    // Always set initial onclick to check authentication
                    disagreeButton.onclick = function() {
                        const currentUser = firebase.auth().currentUser;
                        if (!currentUser) {
                            alert('You must be logged in to disagree with a premise.');
                            return;
                        }
                        updateDisagreement(this.dataset.argumentId, parseInt(this.dataset.premiseIndex));
                    };
                    
                    // If user is logged in, check their voting status
                    if (user) {
                        Promise.all([
                            checkUserEndorsement(argumentObj.id),
                            checkUserDisagreement(argumentObj.id, index)
                        ]).then(([hasEndorsed, hasDisagreed]) => {
                            if (hasEndorsed) {
                                // User endorsed, so disable disagree button
                                disagreeButton.textContent = 'Already endorsed conclusion';
                                disagreeButton.disabled = true;
                                disagreeButton.style.backgroundColor = '#6c757d';
                                disagreeButton.style.cursor = 'not-allowed';
                                disagreeButton.onclick = null;
                            } else if (hasDisagreed) {
                                // User already disagreed with this premise
                                disagreeButton.textContent = 'Remove Disagreement';
                                disagreeButton.style.backgroundColor = '#6c757d';
                                disagreeButton.onclick = function() {
                                    removeDisagreement(this.dataset.argumentId, parseInt(this.dataset.premiseIndex));
                                };
                            }
                        });
                    }
                    
                    voteContainer.appendChild(disagreeButton);
                    li.appendChild(voteContainer);
                } else {
                    const endorseButton = document.createElement('button');
                    endorseButton.textContent = 'Endorse Conclusion';
                    endorseButton.className = 'endorse-conclusion-button';
                    endorseButton.dataset.argumentId = argumentObj.id;
                    
                    // Always set initial onclick to check authentication
                    endorseButton.onclick = function() {
                        const currentUser = firebase.auth().currentUser;
                        if (!currentUser) {
                            alert('You must be logged in to endorse the conclusion.');
                            return;
                        }
                        updateEndorsement(this.dataset.argumentId);
                    };
                    
                    // If user is logged in, check their voting status
                    if (user) {
                        Promise.all([
                            checkUserEndorsement(argumentObj.id),
                            checkUserAnyDisagreement(argumentObj.id)
                        ]).then(([hasEndorsed, hasDisagreed]) => {
                            if (hasDisagreed) {
                                // User disagreed with a premise, so disable endorse button
                                endorseButton.textContent = 'Already disagreed with premise';
                                endorseButton.disabled = true;
                                endorseButton.style.backgroundColor = '#6c757d';
                                endorseButton.style.cursor = 'not-allowed';
                                endorseButton.onclick = null;
                            } else if (hasEndorsed) {
                                // User already endorsed
                                endorseButton.textContent = 'Remove Endorsement';
                                endorseButton.style.backgroundColor = '#6c757d';
                                endorseButton.onclick = function() {
                                    removeEndorsement(this.dataset.argumentId);
                                };
                            }
                        });
                    }
                    
                    li.appendChild(document.createElement('br'));
                    li.appendChild(endorseButton);
                }

                ol.appendChild(li);
            });

            argumentContentDiv.appendChild(ol);

            // Display endorsement stats
            const endorsementStats = document.createElement('div');
            endorsementStats.className = 'endorsement-stats';
            endorsementStats.textContent = `Endorsements: ${argumentObj.endorsements || 0} | Disagreements: ${argumentObj.disagreements || 0} | Endorsement Percentage: ${argumentObj.endorsementPercentage ? argumentObj.endorsementPercentage.toFixed(2) : 0}%`;

            argumentDiv.appendChild(argumentHeader);
            argumentDiv.appendChild(claimElement);
            argumentDiv.appendChild(argumentContentDiv);
            argumentDiv.appendChild(endorsementStats);

            container.appendChild(argumentDiv);
        }

        function updateEndorsement(argumentId) {
            const user = firebase.auth().currentUser;
            if (!user) {
                alert('You must be logged in to endorse.');
                return;
            }
            
            const argumentRef = db.collection('arguments').doc(argumentId);
            const endorsementRef = db.collection('arguments').doc(argumentId).collection('endorsements').doc(user.uid);
            const disagreementRef = db.collection('arguments').doc(argumentId).collection('disagreements').doc(user.uid);
            
            // Check if user already endorsed
            endorsementRef.get().then((doc) => {
                if (doc.exists) {
                    alert('You have already endorsed this argument.');
                    return;
                }
                
                // Use a transaction to update endorsement and remove any disagreement
                return db.runTransaction((transaction) => {
                    return transaction.get(argumentRef).then((doc) => {
                        if (!doc.exists) {
                            throw "Argument does not exist!";
                        }
                        
                        // Check if user has a disagreement to remove
                        return transaction.get(disagreementRef).then((disagreeDoc) => {
                            let newEndorsements = (doc.data().endorsements || 0) + 1;
                            let disagreements = doc.data().disagreements || 0;
                            
                            // If user had disagreed, remove that disagreement
                            if (disagreeDoc.exists) {
                                disagreements = Math.max(0, disagreements - 1);
                            }
                            
                            const totalVotes = newEndorsements + disagreements;
                            const endorsementPercentage = totalVotes > 0 ? (100 * newEndorsements) / totalVotes : 0;
                            
                            // Update the argument
                            transaction.update(argumentRef, {
                                endorsements: newEndorsements,
                                disagreements: disagreements,
                                endorsementPercentage: endorsementPercentage
                            });
                            
                            // Record that this user endorsed
                            transaction.set(endorsementRef, {
                                timestamp: firebase.firestore.FieldValue.serverTimestamp()
                            });
                            
                            // Remove any disagreement
                            if (disagreeDoc.exists) {
                                transaction.delete(disagreementRef);
                            }
                        });
                    });
                });
            }).then(() => {
                alert('You endorsed the conclusion.');
                displayArguments();
            }).catch((error) => {
                console.error("Transaction failed: ", error);
                if (error !== 'You have already endorsed this argument.') {
                    alert("Error endorsing: " + error);
                }
            });
        }

        function updateDisagreement(argumentId, premiseIndex) {
            const user = firebase.auth().currentUser;
            if (!user) {
                alert('You must be logged in to disagree.');
                return;
            }
            
            const argumentRef = db.collection('arguments').doc(argumentId);
            const disagreementRef = db.collection('arguments').doc(argumentId).collection('disagreements').doc(user.uid);
            const endorsementRef = db.collection('arguments').doc(argumentId).collection('endorsements').doc(user.uid);
            
            // Check if user already disagreed
            disagreementRef.get().then((doc) => {
                if (doc.exists) {
                    alert('You have already disagreed with this argument.');
                    return;
                }
                
                // Use a transaction to update disagreement and remove any endorsement
                return db.runTransaction((transaction) => {
                    return transaction.get(argumentRef).then((doc) => {
                        if (!doc.exists) {
                            throw "Argument does not exist!";
                        }
                        
                        // Check if user has an endorsement to remove
                        return transaction.get(endorsementRef).then((endorseDoc) => {
                            let newDisagreements = (doc.data().disagreements || 0) + 1;
                            let endorsements = doc.data().endorsements || 0;
                            
                            // If user had endorsed, remove that endorsement
                            if (endorseDoc.exists) {
                                endorsements = Math.max(0, endorsements - 1);
                            }
                            
                            const totalVotes = newDisagreements + endorsements;
                            const endorsementPercentage = totalVotes > 0 ? (100 * endorsements) / totalVotes : 0;
                            
                            // Update the argument
                            transaction.update(argumentRef, {
                                disagreements: newDisagreements,
                                endorsements: endorsements,
                                endorsementPercentage: endorsementPercentage
                            });
                            
                            // Record that this user disagreed and which premise
                            transaction.set(disagreementRef, {
                                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                                premiseIndex: premiseIndex
                            });
                            
                            // Remove any endorsement
                            if (endorseDoc.exists) {
                                transaction.delete(endorsementRef);
                            }
                        });
                    });
                });
            }).then(() => {
                alert('You disagreed with a premise.');
                displayArguments();
            }).catch((error) => {
                console.error("Transaction failed: ", error);
                if (error !== 'You have already disagreed with this argument.') {
                    alert("Error disagreeing: " + error);
                }
            });
        }
        
        function checkUserEndorsement(argumentId) {
            const user = firebase.auth().currentUser;
            if (!user) return Promise.resolve(false);
            
            return db.collection('arguments').doc(argumentId).collection('endorsements').doc(user.uid)
                .get()
                .then(doc => doc.exists);
        }
        
        function checkUserDisagreement(argumentId, premiseIndex) {
            const user = firebase.auth().currentUser;
            if (!user) return Promise.resolve(false);
            
            return db.collection('arguments').doc(argumentId).collection('disagreements').doc(user.uid)
                .get()
                .then(doc => doc.exists && doc.data().premiseIndex === premiseIndex);
        }
        
        function checkUserAnyDisagreement(argumentId) {
            const user = firebase.auth().currentUser;
            if (!user) return Promise.resolve(false);
            
            return db.collection('arguments').doc(argumentId).collection('disagreements').doc(user.uid)
                .get()
                .then(doc => doc.exists);
        }
        
        function removeEndorsement(argumentId) {
            const user = firebase.auth().currentUser;
            if (!user) {
                alert('You must be logged in.');
                return;
            }
            
            const argumentRef = db.collection('arguments').doc(argumentId);
            const endorsementRef = db.collection('arguments').doc(argumentId).collection('endorsements').doc(user.uid);
            
            db.runTransaction((transaction) => {
                return transaction.get(argumentRef).then((doc) => {
                    if (!doc.exists) {
                        throw "Argument does not exist!";
                    }
                    
                    const currentEndorsements = Math.max(0, (doc.data().endorsements || 0) - 1);
                    const disagreements = doc.data().disagreements || 0;
                    const totalVotes = currentEndorsements + disagreements;
                    const endorsementPercentage = totalVotes > 0 ? (100 * currentEndorsements) / totalVotes : 0;
                    
                    // Update the argument
                    transaction.update(argumentRef, {
                        endorsements: currentEndorsements,
                        endorsementPercentage: endorsementPercentage
                    });
                    
                    // Remove the endorsement record
                    transaction.delete(endorsementRef);
                });
            }).then(() => {
                alert('Endorsement removed.');
                displayArguments();
            }).catch((error) => {
                console.error("Transaction failed: ", error);
                alert("Error removing endorsement: " + error);
            });
        }
        
        function removeDisagreement(argumentId, premiseIndex) {
            const user = firebase.auth().currentUser;
            if (!user) {
                alert('You must be logged in.');
                return;
            }
            
            const argumentRef = db.collection('arguments').doc(argumentId);
            const disagreementRef = db.collection('arguments').doc(argumentId).collection('disagreements').doc(user.uid);
            
            db.runTransaction((transaction) => {
                return transaction.get(argumentRef).then((doc) => {
                    if (!doc.exists) {
                        throw "Argument does not exist!";
                    }
                    
                    const currentDisagreements = Math.max(0, (doc.data().disagreements || 0) - 1);
                    const endorsements = doc.data().endorsements || 0;
                    const totalVotes = currentDisagreements + endorsements;
                    const endorsementPercentage = totalVotes > 0 ? (100 * endorsements) / totalVotes : 0;
                    
                    // Update the argument
                    transaction.update(argumentRef, {
                        disagreements: currentDisagreements,
                        endorsementPercentage: endorsementPercentage
                    });
                    
                    // Remove the disagreement record
                    transaction.delete(disagreementRef);
                });
            }).then(() => {
                alert('Disagreement removed.');
                displayArguments();
            }).catch((error) => {
                console.error("Transaction failed: ", error);
                alert("Error removing disagreement: " + error);
            });
        }
        
        function populateFilterClaims() {
            const filterClaimSelect = document.getElementById('filterClaimSelect');
            if (!filterClaimSelect) return;
            
            filterClaimSelect.innerHTML = '<option value="">-- All Claims --</option>';
            const claimsSet = new Set();

            // Collect all claims
            for (const category in claimsByCategory) {
                for (const subcategory in claimsByCategory[category]) {
                    claimsByCategory[category][subcategory].forEach(claim => {
                        claimsSet.add(claim.text);
                    });
                }
            }

            // Add claims to the select element
            claimsSet.forEach(claimText => {
                const option = document.createElement('option');
                option.value = claimText;
                option.textContent = claimText;
                filterClaimSelect.appendChild(option);
            });
        }

        // Stubs for old functions
        function displayArgumentForms(stance) { console.log("Old displayArgumentForms called - Templates disabled."); }
        function generatePlaceholderInputs(form) { console.log("Old generatePlaceholderInputs called - Templates disabled."); }
        function createVariableRectangles(text, placeholderValues, isForm = false) { return text; }
        function constructArgument(form, placeholderValues) { return []; }
        function collectPremiseURLs(form) { return {}; }
        function validateArgument(form, placeholderValues) { return true; } 

        // Wait for DOM to be ready
        function initializeApp() {
            console.log("Script 2: initializeApp called");
            
            // Populate category dropdown
            const categorySelect = document.getElementById('categorySelect');
            if (categorySelect) {
                console.log("Script 2: Found categorySelect element");
                for (const category in claimsByCategory) {
                    const option = document.createElement('option');
                    option.value = category;
                    option.textContent = category;
                    categorySelect.appendChild(option);
                }
                console.log("Script 2: Categories populated");
                
                // Set up category change listener
                categorySelect.addEventListener('change', function() {
                    const subcategorySelect = document.getElementById('subcategorySelect');
                    const claimSelect = document.getElementById('claimSelect');
                    
                    subcategorySelect.innerHTML = '<option value="">-- Choose a Subcategory --</option>';
                    claimSelect.innerHTML = '<option value="">-- Choose a Claim --</option>';
                    
                    const selectedCategory = this.value;
                    if (selectedCategory && claimsByCategory[selectedCategory]) {
                        for (const subcategory in claimsByCategory[selectedCategory]) {
                            const option = document.createElement('option');
                            option.value = subcategory;
                            option.textContent = subcategory;
                            subcategorySelect.appendChild(option);
                        }
                    }
                    
                    // Reset subsequent selections
                    const stanceSelect = document.getElementById('stanceSelect');
                    if(stanceSelect) stanceSelect.value = "";
                    document.getElementById('dynamicArgumentBuilder').style.display = 'none';
                    const statementDefArea = document.getElementById('statementDefinitionArea');
                    if (statementDefArea) statementDefArea.style.display = 'none';
                    const validityResultDiv = document.getElementById('validityResult');
                    if(validityResultDiv) validityResultDiv.textContent = '';
                });
            }
            
            // Set up subcategory change listener
            const subcategorySelect = document.getElementById('subcategorySelect');
            if (subcategorySelect) {
                subcategorySelect.addEventListener('change', function() {
                    const categorySelect = document.getElementById('categorySelect');
                    const claimSelect = document.getElementById('claimSelect');
                    
                    claimSelect.innerHTML = '<option value="">-- Choose a Claim --</option>';
                    
                    const selectedCategory = categorySelect.value;
                    const selectedSubcategory = this.value;
                    
                    if (selectedCategory && selectedSubcategory && 
                        claimsByCategory[selectedCategory] && 
                        claimsByCategory[selectedCategory][selectedSubcategory]) {
                        
                        claimsByCategory[selectedCategory][selectedSubcategory].forEach(claim => {
                            const option = document.createElement('option');
                            option.value = claim.value;
                            option.textContent = claim.text;
                            claimSelect.appendChild(option);
                        });
                    }
                    
                    populateFilterClaims();
                    
                    // Reset subsequent selections
                    const stanceSelect = document.getElementById('stanceSelect');
                    if(stanceSelect) stanceSelect.value = "";
                    document.getElementById('dynamicArgumentBuilder').style.display = 'none';
                    const statementDefArea = document.getElementById('statementDefinitionArea');
                    if (statementDefArea) statementDefArea.style.display = 'none';
                    const validityResultDiv = document.getElementById('validityResult');
                    if(validityResultDiv) validityResultDiv.textContent = '';
                });
            }
            
            // Set up claim change listener
            const claimSelect = document.getElementById('claimSelect');
            if (claimSelect) {
                claimSelect.addEventListener('change', function() {
                    const stanceSelect = document.getElementById('stanceSelect');
                    if(stanceSelect) stanceSelect.value = ""; 
                    document.getElementById('dynamicArgumentBuilder').style.display = 'none';
                    const statementDefArea = document.getElementById('statementDefinitionArea');
                    if (statementDefArea) statementDefArea.style.display = 'none';
                    const validityResultDiv = document.getElementById('validityResult');
                    if(validityResultDiv) validityResultDiv.textContent = '';
                });
            }
            
            // Set up button
            const setClaimAndBuildButton = document.getElementById('setClaimAndBuildButton');
            if (setClaimAndBuildButton) {
                setClaimAndBuildButton.addEventListener('click', initializeAndShowDynamicBuilder);
            }
            
            // Set up ranking
            const rankingSelect = document.getElementById('rankingSelect');
            if (rankingSelect) {
                rankingSelect.addEventListener('change', function() {
                    // Reset the view when changing sort method
                    window.availableArguments = null;
                    window.shownArgumentIds = null;
                    displayArguments();
                });
            }
            
            // Initial calls
            populateFilterClaims();
            // Display a random argument by default
            setTimeout(() => {
                displayArguments();
            }, 500);
        }

        // Auth state listener
        firebase.auth().onAuthStateChanged(function(user) {
            const authContainer = document.getElementById('authContainer');
            const logoutButton = document.getElementById('logoutButton');
            const claimSetupForm = document.getElementById('claimSetupForm');
            const dynamicBuilderSection = document.getElementById('dynamicArgumentBuilder');
            
            if (user) {
                if (authContainer) authContainer.style.display = 'none';
                if (logoutButton) logoutButton.style.display = 'block';
            } else {
                if (authContainer) authContainer.style.display = 'block';
                if (logoutButton) logoutButton.style.display = 'none';
                if(dynamicBuilderSection) dynamicBuilderSection.style.display = 'none';
            }
            
            // Always show claim setup form
            if (claimSetupForm) claimSetupForm.style.display = 'block';
        });

        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeApp);
        } else {
            initializeApp();
        }
        
        console.log("Script 2: Main script completed");
        
        // Mobile-specific enhancements
        function initializeMobileFeatures() {
            // Detect if mobile device
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || window.innerWidth <= 768;
            
            if (isMobile) {
                // Add touch class to body
                document.body.classList.add('touch-device');
                
                // Initialize touch gestures
                initializeTouchGestures();
                
                // Initialize pull to refresh
                initializePullToRefresh();
                
                // Improve form interactions
                improveMobileForms();
                
                // Add mobile-specific event handlers
                addMobileHandlers();
            }
        }
        
        function initializeTouchGestures() {
            let touchStartX = 0;
            let touchStartY = 0;
            
            // Add swipe detection to premise slots
            document.addEventListener('touchstart', function(e) {
                const premiseSlot = e.target.closest('.premise-slot');
                if (premiseSlot) {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                }
            });
            
            document.addEventListener('touchend', function(e) {
                const premiseSlot = e.target.closest('.premise-slot');
                if (premiseSlot) {
                    const touchEndX = e.changedTouches[0].clientX;
                    const touchEndY = e.changedTouches[0].clientY;
                    const diffX = touchStartX - touchEndX;
                    const diffY = Math.abs(touchStartY - touchEndY);
                    
                    // Only register horizontal swipes
                    if (diffX > 50 && diffY < 100) {
                        premiseSlot.classList.add('swiped');
                        setTimeout(() => {
                            premiseSlot.classList.remove('swiped');
                        }, 3000);
                    }
                }
            });
        }
        
        function initializePullToRefresh() {
            let startY = 0;
            let isPulling = false;
            
            document.addEventListener('touchstart', function(e) {
                if (window.scrollY === 0) {
                    startY = e.touches[0].clientY;
                    isPulling = true;
                }
            });
            
            document.addEventListener('touchmove', function(e) {
                if (!isPulling) return;
                
                const currentY = e.touches[0].clientY;
                const diff = currentY - startY;
                
                if (diff > 0 && diff < 150) {
                    const pullToRefresh = document.querySelector('.pull-to-refresh');
                    pullToRefresh.style.transform = `translateY(${diff}px)`;
                }
            });
            
            document.addEventListener('touchend', function(e) {
                if (!isPulling) return;
                
                const pullToRefresh = document.querySelector('.pull-to-refresh');
                const currentY = e.changedTouches[0].clientY;
                const diff = currentY - startY;
                
                if (diff > 100) {
                    // Trigger refresh
                    pullToRefresh.innerHTML = '<i class="fas fa-sync fa-spin"></i> <span style="margin-left: 10px;">Refreshing...</span>';
                    location.reload();
                } else {
                    pullToRefresh.style.transform = 'translateY(0)';
                }
                
                isPulling = false;
            });
        }
        
        function improveMobileForms() {
            // Add touch-friendly class to all interactive elements
            const interactiveElements = document.querySelectorAll('button, select, input, .palette-item, .drop-zone');
            interactiveElements.forEach(el => {
                el.classList.add('touchable');
            });
            
            // Improve select elements on iOS
            const selects = document.querySelectorAll('select');
            selects.forEach(select => {
                select.addEventListener('focus', function() {
                    this.size = Math.min(this.options.length, 5);
                });
                select.addEventListener('blur', function() {
                    this.size = 0;
                });
                select.addEventListener('change', function() {
                    this.size = 0;
                    this.blur();
                });
            });
        }
        
        function addMobileHandlers() {
            // Long press to edit propositions
            let pressTimer;
            document.addEventListener('touchstart', function(e) {
                const proposition = e.target.closest('.palette-item.proposition');
                if (proposition && !proposition.classList.contains('prop-k')) {
                    pressTimer = setTimeout(() => {
                        const letter = proposition.textContent.trim().charAt(0);
                        if (window.editPropositionText) {
                            navigator.vibrate && navigator.vibrate(50);
                            window.editPropositionText(letter);
                        }
                    }, 500);
                }
            });
            
            document.addEventListener('touchend', function() {
                clearTimeout(pressTimer);
            });
            
            // Double tap to validate
            let lastTap = 0;
            document.addEventListener('touchend', function(e) {
                const argumentBuilder = e.target.closest('#dynamicArgumentBuilder');
                if (argumentBuilder) {
                    const currentTime = new Date().getTime();
                    const tapGap = currentTime - lastTap;
                    if (tapGap < 300 && tapGap > 0) {
                        document.getElementById('checkFormValidityButton').click();
                    }
                    lastTap = currentTime;
                }
            });
        }
        
        // Mobile utility functions
        function scrollToTop() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }
        
        function showMobileMenu() {
            // Create a simple mobile menu
            const menuItems = [
                { text: 'My Arguments', action: () => console.log('Show user arguments') },
                { text: 'Settings', action: () => console.log('Show settings') },
                { text: 'Help', action: () => showMobileAlert('Swipe left on premises to see options. Long press to edit.', 'info') },
                { text: 'Logout', action: () => document.getElementById('logoutButton').click() }
            ];
            
            // You could implement a proper menu modal here
            showMobileAlert('Menu coming soon!', 'info');
        }
        
        function showMobileAlert(message, type = 'error') {
            const alertEl = document.getElementById('mobileAlert');
            alertEl.textContent = message;
            alertEl.className = `mobile-alert ${type} show`;
            
            setTimeout(() => {
                alertEl.classList.remove('show');
            }, 3000);
        }
        
        // Replace default alerts with mobile-friendly ones on mobile devices
        if (window.innerWidth <= 768) {
            const originalAlert = window.alert;
            window.alert = function(message) {
                showMobileAlert(message, 'info');
            };
        }
        
        // Initialize mobile features when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeMobileFeatures);
        } else {
            initializeMobileFeatures();
        }
        
        // PWA Installation
        let deferredPrompt;
        
        // Register Service Worker
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => {
                        console.log('ServiceWorker registration successful');
                        
                        // Check for updates periodically
                        setInterval(() => {
                            registration.update();
                        }, 60000); // Check every minute
                    })
                    .catch(err => {
                        console.log('ServiceWorker registration failed: ', err);
                    });
            });
        }
        
        // Listen for beforeinstallprompt
        window.addEventListener('beforeinstallprompt', (e) => {
            // Prevent Chrome 67 and earlier from automatically showing the prompt
            e.preventDefault();
            // Stash the event so it can be triggered later
            deferredPrompt = e;
        });
        
        function showInstallPromotion() {
            // Create install banner
            const installBanner = document.createElement('div');
            installBanner.id = 'installBanner';
            installBanner.style.cssText = `
                position: fixed;
                bottom: 80px;
                left: 20px;
                right: 20px;
                background: #007bff;
                color: white;
                padding: 15px;
                border-radius: 10px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                display: flex;
                align-items: center;
                justify-content: space-between;
                z-index: 1000;
                transform: translateY(200px);
                transition: transform 0.3s ease;
            `;
            
            installBanner.innerHTML = `
                <div>
                    <strong>Install Crux</strong>
                    <p style="margin: 5px 0 0 0; font-size: 14px;">Add to your home screen for the best experience</p>
                </div>
                <button id="installBtn" style="
                    background: white;
                    color: #007bff;
                    border: none;
                    padding: 10px 20px;
                    border-radius: 6px;
                    font-weight: bold;
                    cursor: pointer;
                ">Install</button>
            `;
            
            document.body.appendChild(installBanner);
            
            // Animate in
            setTimeout(() => {
                installBanner.style.transform = 'translateY(0)';
            }, 100);
            
            // Install button click
            document.getElementById('installBtn').addEventListener('click', async () => {
                if (deferredPrompt) {
                    deferredPrompt.prompt();
                    const { outcome } = await deferredPrompt.userChoice;
                    console.log(`User response to the install prompt: ${outcome}`);
                    deferredPrompt = null;
                    installBanner.remove();
                }
            });
            
            // Close button
            const closeBtn = document.createElement('button');
            closeBtn.innerHTML = '×';
            closeBtn.style.cssText = `
                position: absolute;
                top: 5px;
                right: 5px;
                background: none;
                border: none;
                color: white;
                font-size: 24px;
                cursor: pointer;
                padding: 0;
                width: 30px;
                height: 30px;
            `;
            closeBtn.onclick = () => {
                installBanner.style.transform = 'translateY(200px)';
                setTimeout(() => installBanner.remove(), 300);
            };
            installBanner.appendChild(closeBtn);
        }
        
        // Detect if app is installed
        window.addEventListener('appinstalled', () => {
            console.log('Crux was installed');
            // Hide install promotion
            const banner = document.getElementById('installBanner');
            if (banner) banner.remove();
        });
        
        // iOS install instructions
        function showiOSInstallInstructions() {
            if (window.navigator.standalone) {
                return; // Already installed
            }
            
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
            
            if (isIOS && !localStorage.getItem('iosInstallDismissed')) {
                const instructions = document.createElement('div');
                instructions.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    left: 20px;
                    right: 20px;
                    background: white;
                    padding: 20px;
                    border-radius: 12px;
                    box-shadow: 0 4px 20px rgba(0,0,0,0.1);
                    z-index: 1000;
                `;
                
                instructions.innerHTML = `
                    <h3 style="margin: 0 0 10px 0;">Install Crux</h3>
                    <p style="margin: 0 0 15px 0; font-size: 14px;">
                        Tap <img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTEwIDAuNVYxMy41TTEwIDEzLjVMNiA5LjVNMTAgMTMuNUwxNCA5LjUiIHN0cm9rZT0iIzAwN0FGRiIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPHBhdGggZD0iTTEgMTRIMTlWMTlIMVYxNFoiIHN0cm9rZT0iIzAwN0FGRiIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPC9zdmc+" style="width: 20px; height: 20px; vertical-align: middle;"> 
                        then "Add to Home Screen"
                    </p>
                    <button onclick="this.parentElement.remove(); localStorage.setItem('iosInstallDismissed', 'true');" style="
                        background: #007bff;
                        color: white;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 6px;
                        width: 100%;
                        font-weight: bold;
                    ">Got it</button>
                `;
                
                document.body.appendChild(instructions);
            }
        }
        
    </script>
</body>
</html>