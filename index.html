<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="theme-color" content="#007bff">
    <meta name="description" content="Build and evaluate logical arguments with formal validity checking">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="/manifest.json">
    
    <!-- iOS Icons -->
    <link rel="apple-touch-icon" href="/icons/icon-152x152.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/icons/icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/icons/icon-180x180.png">
    <link rel="apple-touch-icon" sizes="167x167" href="/icons/icon-167x167.png">
    
    <!-- Splash Screens for iOS -->
    <link rel="apple-touch-startup-image" href="/splash/launch-640x1136.png" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2)">
    <link rel="apple-touch-startup-image" href="/splash/launch-750x1334.png" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2)">
    <link rel="apple-touch-startup-image" href="/splash/launch-1242x2208.png" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3)">
    
    <title>Crux</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" />
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Enhanced Modern Design System - Add this to your existing styles or replace the <style> section */
:root {
    --primary: #667eea;
    --primary-dark: #5a67d8;
    --primary-light: #7c8ff5;
    --secondary: #48bb78;
    --danger: #f56565;
    --warning: #ed8936;
    --info: #4299e1;
    --dark: #1a1a2e;
    --dark-lighter: #16213e;
    --gray-100: #f7fafc;
    --gray-200: #edf2f7;
    --gray-300: #e2e8f0;
    --gray-400: #cbd5e0;
    --gray-500: #a0aec0;
    --gray-600: #718096;
    --gray-700: #4a5568;
    --gray-800: #2d3748;
    --gray-900: #1a202c;
    --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
    --shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
    --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
    --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
    --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

* {
    box-sizing: border-box;
}

body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    margin: 0;
    padding: 0;
    color: var(--gray-900);
    line-height: 1.6;
}

body::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23ffffff' fill-opacity='0.03'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
    pointer-events: none;
    z-index: 0;
}

.container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 20px;
    position: relative;
    z-index: 1;
}

/* Typography */
h1 {
    font-size: 3.5rem;
    font-weight: 700;
    text-align: center;
    color: white;
    margin: 2rem 0 3rem;
    text-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    letter-spacing: -0.025em;
}

h2 {
    font-size: 1.875rem;
    font-weight: 600;
    color: var(--gray-900);
    margin-bottom: 1.5rem;
    letter-spacing: -0.025em;
}

h3 {
    font-size: 1.25rem;
    font-weight: 600;
    color: var(--gray-800);
    margin-bottom: 1rem;
}

/* Enhanced Form Styles */
form {
    background: white;
    border-radius: 16px;
    box-shadow: var(--shadow-xl);
    padding: 2rem;
    margin-bottom: 2rem;
    transition: var(--transition);
    border: 1px solid rgba(0, 0, 0, 0.05);
}

form:hover {
    transform: translateY(-2px);
    box-shadow: 0 25px 30px -10px rgba(0, 0, 0, 0.15);
}

label {
    display: block;
    font-weight: 500;
    color: var(--gray-700);
    margin-bottom: 0.5rem;
    font-size: 0.875rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
}

select, input[type="text"], input[type="url"], input[type="email"], input[type="password"], textarea {
    width: 100%;
    padding: 0.75rem 1rem;
    border: 2px solid var(--gray-300);
    border-radius: 8px;
    font-size: 1rem;
    transition: var(--transition);
    background: white;
    font-family: inherit;
}

select:focus, input:focus, textarea:focus {
    outline: none;
    border-color: var(--primary);
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
}

/* Enhanced Button Styles */
button {
    padding: 0.75rem 1.5rem;
    font-weight: 600;
    font-size: 0.875rem;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: var(--transition);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    position: relative;
    overflow: hidden;
    background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
    color: white;
}

button::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0;
    height: 0;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.2);
    transform: translate(-50%, -50%);
    transition: width 0.6s, height 0.6s;
}

button:active::before {
    width: 300px;
    height: 300px;
}

button:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow-lg);
}

button[type="submit"] {
    width: 100%;
    padding: 1rem;
    font-size: 1rem;
    margin-top: 2rem;
}

#addPremiseButton {
    background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
}

#removePremiseButton {
    background: linear-gradient(135deg, var(--danger) 0%, #e53e3e 100%);
}

#checkFormValidityButton {
    background: linear-gradient(135deg, var(--secondary) 0%, #38a169 100%);
}

#defineStatementsNowButton {
    background: linear-gradient(135deg, var(--gray-600) 0%, var(--gray-700) 100%);
}

/* Authentication Container */
#authContainer {
    max-width: 800px;
    margin: 0 auto 2rem;
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 2rem;
}

#authContainer > div {
    background: white;
    padding: 2rem;
    border-radius: 16px;
    box-shadow: var(--shadow-xl);
}

#authContainer h2 {
    text-align: center;
    color: var(--primary);
    margin-bottom: 2rem;
}

/* Dynamic Argument Builder */
#dynamicArgumentBuilder {
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    border-radius: 16px;
    padding: 2rem;
    box-shadow: var(--shadow-xl);
    margin-top: 2rem;
}

.builder-container {
    display: grid;
    grid-template-columns: 300px 1fr;
    gap: 2rem;
    margin-top: 2rem;
}

/* Enhanced Palette */
.palette {
    background: var(--gray-100);
    border-radius: 12px;
    padding: 1.5rem;
    box-shadow: var(--shadow-md);
    position: sticky;
    top: 20px;
    max-height: calc(100vh - 40px);
    overflow-y: auto;
}

.palette h3 {
    color: var(--primary);
    font-size: 1.125rem;
    margin-bottom: 1rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
}

.palette-section h4 {
    font-size: 0.875rem;
    color: var(--gray-600);
    margin-bottom: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
}

.palette-item {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 0.5rem 1rem;
    margin: 0.25rem;
    border-radius: 8px;
    font-weight: 600;
    font-size: 0.875rem;
    cursor: grab;
    transition: var(--transition);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    min-width: 48px;
    box-shadow: var(--shadow-sm);
}

.palette-item:hover {
    transform: translateY(-2px) scale(1.05);
    box-shadow: var(--shadow-md);
}

.palette-item.proposition {
    color: white;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
}

/* Proposition Colors with Gradients */
.prop-a { background: linear-gradient(135deg, #E74C3C, #c0392b); }
.prop-b { background: linear-gradient(135deg, #3498DB, #2980b9); }
.prop-c { background: linear-gradient(135deg, #2ECC71, #27ae60); }
.prop-d { background: linear-gradient(135deg, #F1C40F, #f39c12); }
.prop-e { background: linear-gradient(135deg, #E67E22, #d35400); }
.prop-f { background: linear-gradient(135deg, #1ABC9C, #16a085); }
.prop-g { background: linear-gradient(135deg, #34495E, #2c3e50); }
.prop-h { background: linear-gradient(135deg, #7F8C8D, #6c7a7b); }
.prop-i { background: linear-gradient(135deg, #C0392B, #a93226); }
.prop-j { background: linear-gradient(135deg, #16A085, #138d75); }
.prop-k { background: linear-gradient(135deg, #9B59B6, #8e44ad); }

.palette-item.operator {
    background: linear-gradient(135deg, var(--gray-200), var(--gray-300));
    color: var(--gray-700);
    border: 1px solid var(--gray-400);
    font-family: 'JetBrains Mono', 'Courier New', monospace;
}

/* Enhanced Workspace */
.workspace {
    background: white;
    border-radius: 12px;
    padding: 2rem;
    box-shadow: var(--shadow-md);
}

.premise-slot {
    background: var(--gray-50);
    border: 2px dashed var(--gray-300);
    border-radius: 12px;
    padding: 1.5rem;
    margin-bottom: 1rem;
    transition: var(--transition);
}

.premise-slot:hover {
    border-color: var(--gray-400);
    background: var(--gray-100);
}

.drop-zone {
    min-height: 60px;
    padding: 1rem;
    background: white;
    border: 2px solid var(--gray-300);
    border-radius: 8px;
    transition: var(--transition);
    display: flex;
    align-items: center;
}

.drop-zone.drag-over {
    background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(102, 126, 234, 0.2));
    border-color: var(--primary);
    transform: scale(1.02);
}

.sub-drop-zone {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 0.5rem 1rem;
    border: 2px dashed var(--gray-400);
    border-radius: 6px;
    min-width: 60px;
    min-height: 40px;
    background: var(--gray-50);
    margin: 0 0.25rem;
    transition: var(--transition);
}

.sub-drop-zone:hover {
    background: var(--gray-100);
    border-color: var(--primary);
}

/* Conclusion Area */
.conclusion-area {
    background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(102, 126, 234, 0.05));
    border: 2px solid var(--primary);
    border-radius: 12px;
    padding: 1.5rem;
    margin-top: 2rem;
}

/* Trash Can */
#trashCanArea {
    background: linear-gradient(135deg, var(--gray-100), var(--gray-200));
    border: 2px dashed var(--gray-400);
    border-radius: 12px;
    padding: 1.5rem;
    text-align: center;
    transition: var(--transition);
    cursor: pointer;
    margin-top: 2rem;
}

#trashCanArea:hover {
    background: linear-gradient(135deg, #fee2e2, #fecaca);
    border-color: var(--danger);
    transform: scale(1.02);
}

#trashCanArea i {
    font-size: 2rem;
    color: var(--gray-600);
    transition: var(--transition);
}

#trashCanArea:hover i {
    color: var(--danger);
    transform: scale(1.1);
}

/* Enhanced Arguments Display */
.argument {
    background: white;
    border-radius: 16px;
    padding: 2rem;
    margin-bottom: 2rem;
    box-shadow: var(--shadow-lg);
    border-left: 4px solid var(--primary);
    transition: var(--transition);
}

.argument:hover {
    transform: translateX(4px);
    box-shadow: var(--shadow-xl);
}

.argument-header {
    display: flex;
    align-items: center;
    gap: 1.5rem;
    margin-bottom: 1.5rem;
}

.argument-icon {
    font-size: 3rem;
    color: var(--primary);
    background: rgba(102, 126, 234, 0.1);
    width: 80px;
    height: 80px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
}

.argument-content li {
    position: relative;
    padding: 1.5rem;
    margin-bottom: 1rem;
    background: var(--gray-50);
    border-radius: 12px;
    border-left: 3px solid var(--primary);
    transition: var(--transition);
}

.argument-content li:hover {
    background: var(--gray-100);
    transform: translateX(4px);
}

/* Filter Section */
.argument-filters {
    background: white;
    border-radius: 16px;
    padding: 2rem;
    box-shadow: var(--shadow-lg);
    margin-bottom: 2rem;
}

/* Mobile Responsive Improvements */
@media (max-width: 768px) {
    h1 { font-size: 2.5rem; }
    
    .container { padding: 1rem; }
    
    #authContainer { grid-template-columns: 1fr; }
    
    .builder-container { grid-template-columns: 1fr; }
    
    .palette {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        max-height: 40vh;
        border-radius: 16px 16px 0 0;
        z-index: 50;
        box-shadow: 0 -4px 6px -1px rgba(0, 0, 0, 0.1);
    }
    
    .argument-header {
        flex-direction: column;
        text-align: center;
    }
}

/* Info boxes */
.info-box {
    background: linear-gradient(135deg, rgba(66, 153, 225, 0.1), rgba(66, 153, 225, 0.05));
    border: 1px solid var(--info);
    border-radius: 8px;
    padding: 1rem;
    margin: 1rem 0;
    font-size: 0.875rem;
    color: var(--gray-700);
}

/* Validity Result */
#validityResult {
    padding: 1rem;
    border-radius: 8px;
    margin-top: 1rem;
    font-weight: 500;
    text-align: center;
}

/* Statement Definition Area */
#statementDefinitionArea {
    background: var(--gray-50);
    border-radius: 12px;
    padding: 2rem;
    margin-top: 2rem;
    border: 2px solid var(--gray-300);
}

/* Animations */
@keyframes slideIn {
    from {
        opacity: 0;
        transform: translateY(-10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.combination-prompt {
    animation: slideIn 0.3s ease-out;
}

/* Formula element selection */
.formula-element-wrapper.selected-formula-element > div {
    outline: 3px solid var(--primary);
    outline-offset: 3px;
    box-shadow: 0 0 0 6px rgba(102, 126, 234, 0.2);
}
    </style>
</head>
<body>
    <div class="pull-to-refresh">
        <i class="fas fa-sync"></i> <span style="margin-left: 10px;">Pull to refresh</span>
    </div>
    
    <!-- Mobile Navigation -->
    <nav class="mobile-nav" role="navigation" aria-label="Mobile navigation">
        <button onclick="scrollToTop()" aria-label="Home">
            <i class="fas fa-home"></i>
        </button>
        <button onclick="document.getElementById('claimSetupForm').scrollIntoView()" aria-label="New Argument">
            <i class="fas fa-plus-circle"></i>
        </button>
        <button onclick="document.getElementById('argumentsList').scrollIntoView()" aria-label="View Arguments">
            <i class="fas fa-list"></i>
        </button>
        <button onclick="showMobileMenu()" aria-label="Menu">
            <i class="fas fa-bars"></i>
        </button>
    </nav>
    
    <!-- Mobile Alert Container -->
    <div id="mobileAlert" class="mobile-alert" role="alert"></div>
    
    <div class="container">
        <h1>Crux</h1>

        <div id="authContainer">
            <div id="registerForm">
                <h2>Register</h2>
                <input type="email" id="registerEmail" placeholder="Email" required>
                <input type="password" id="registerPassword" placeholder="Password" required>
                <button type="button" onclick="register()">Register</button>
            </div>
            <div id="loginForm">
                <h2>Login</h2>
                <input type="email" id="loginEmail" placeholder="Email" required>
                <input type="password" id="loginPassword" placeholder="Password" required>
                <button type="button" onclick="login()">Login</button>
            </div>
        </div>

        <button id="logoutButton" type="button" onclick="logout()" style="display:none;">Logout</button>

        <form id="claimSetupForm"> 
            <h2>1. Define Your Argument's Main Claim</h2>
            <label for="categorySelect">Category:</label>
            <select id="categorySelect" required> <option value="">-- Choose a Category --</option></select>
            
            <label for="subcategorySelect">Subcategory:</label>
            <select id="subcategorySelect" required> <option value="">-- Choose a Subcategory --</option> </select>
            
            <label for="claimSelect">Main Claim Statement (K):</label>
            <select id="claimSelect" required> <option value="">-- Choose a Claim --</option> </select>
            
            <label for="stanceSelect">Your Stance on this Claim:</label>
            <select id="stanceSelect" required> 
                <option value="">-- Choose Your Stance --</option> 
                <option value="For">I will argue FOR this claim (Conclusion: K)</option> 
                <option value="Against">I will argue AGAINST this claim (Conclusion: NOT K)</option> 
            </select>
            <button type="button" id="setClaimAndBuildButton">Set Claim & Build Argument Form</button>
        </form>
        
        <form id="argumentForm" style="display:none;">
             <h2>Submit Argument (Template System - Deprecated)</h2>
             <p>This submission method is being phased out. Please use the "Define Your Argument's Main Claim" section above.</p>
             <label for="argumentTitle">Argument Title (Old Template)</label>
            <input type="text" id="argumentTitleOld" placeholder="Enter argument title">
            <div id="argumentFormsContainer" style="display:none;"></div>
            <div id="placeholders" class="placeholders" style="display:none;"></div>
            <button type="submit" id="submitTemplateArgumentButton" style="display:none;">Submit Template Argument</button>
        </form>


        <div id="dynamicArgumentBuilder" style="display:none;">
            <h2>2. Build Your Argument Form</h2>
            <div style="margin-bottom: 15px; padding: 10px; background-color: #e9ecef; border-radius: 4px; border: 1px solid #ced4da;">
                <strong>Main Claim (K):</strong> <span id="displayMainClaimK" style="font-style: italic;">Not yet set</span><br>
                <strong>Your Stance:</strong> You are arguing <span id="displayStanceOnK" style="font-weight:bold;">N/A</span> this claim.
            </div>
            <div class="builder-container">
                <div class="palette">
                    <h3>Palette</h3>
                    <div class="palette-section">
                        <h4>Propositions:</h4>
                        <div class="palette-item proposition prop-a" draggable="true" data-type="proposition" data-letter="A">A</div>
                        <div class="palette-item proposition prop-b" draggable="true" data-type="proposition" data-letter="B">B</div>
                        <div class="palette-item proposition prop-c" draggable="true" data-type="proposition" data-letter="C">C</div>
                        <div class="palette-item proposition prop-d" draggable="true" data-type="proposition" data-letter="D">D</div>
                        <div class="palette-item proposition prop-e" draggable="true" data-type="proposition" data-letter="E">E</div>
                        <div class="palette-item proposition prop-f" draggable="true" data-type="proposition" data-letter="F">F</div>
                        <div class="palette-item proposition prop-g" draggable="true" data-type="proposition" data-letter="G">G</div>
                        <div class="palette-item proposition prop-h" draggable="true" data-type="proposition" data-letter="H">H</div>
                        <div class="palette-item proposition prop-i" draggable="true" data-type="proposition" data-letter="I">I</div>
                        <div class="palette-item proposition prop-j" draggable="true" data-type="proposition" data-letter="J">J</div>
                        <div class="palette-item proposition prop-k" draggable="true" data-type="proposition" data-letter="K" title="This is your Main Claim">K (Main Claim)</div>
                    </div>
                    <div class="palette-section">
                        <h4>Operators:</h4>
                        <div class="palette-item operator op-ifthen" draggable="true" data-type="operator" data-operator="IFTHEN">IF...THEN</div>
                        <div class="palette-item operator op-and" draggable="true" data-type="operator" data-operator="AND">AND</div>
                        <div class="palette-item operator op-or" draggable="true" data-type="operator" data-operator="OR">OR</div>
                        <div class="palette-item operator op-not" draggable="true" data-type="operator" data-operator="NOT">NOT</div>
                    </div>
                     <div id="trashCanArea" style="margin-top: 20px; padding: 10px; border: 2px dashed #ccc; text-align: center; background-color: #f0f0f0;">
                        <i class="fas fa-trash" style="font-size: 24px; color: #777;"></i>
                        <p style="font-size: 12px; color: #777; margin-top: 5px;">Drag here or click selected to delete</p>
                    </div>
                </div>
                <div class="workspace">
                    <h3>Construct Premises:</h3>
                     <label for="dynamicArgumentTitle">Argument Title for this Structure:</label>
                    <input type="text" id="dynamicArgumentTitle" placeholder="Enter title for this argument structure" style="margin-bottom:15px;">
                    <div id="premisesContainer">
                        <div class="premise-slot" id="premise-1-slot-container"> 
                            <span class="premise-label">Premise 1:</span>
                            <div class="drop-zone" id="premise-1-dropzone" data-premise-id="1">[Drop content here]</div>
                            <div class="premise-url-container" style="margin-top: 10px;">
                                <label style="font-size: 14px; font-weight: normal;">Evidence URL (optional):</label>
                                <input type="url" class="premise-url-input" id="premise-1-url" placeholder="https://example.com/evidence" style="width: 100%; margin-top: 5px;">
                                <small style="color: #666; font-size: 12px;">Enter full URL or just domain (e.g., example.com)</small>
                            </div>
                        </div>
                        <div class="premise-slot" id="premise-2-slot-container">
                            <span class="premise-label">Premise 2:</span>
                            <div class="drop-zone" id="premise-2-dropzone" data-premise-id="2">[Drop content here]</div>
                            <div class="premise-url-container" style="margin-top: 10px;">
                                <label style="font-size: 14px; font-weight: normal;">Evidence URL (optional):</label>
                                <input type="url" class="premise-url-input" id="premise-2-url" placeholder="https://example.com/evidence" style="width: 100%; margin-top: 5px;">
                                <small style="color: #666; font-size: 12px;">Enter full URL or just domain (e.g., example.com)</small>
                            </div>
                        </div>
                    </div>
                    <button id="addPremiseButton" type="button">+ Add Premise</button>
                    <button id="removePremiseButton" type="button" style="background-color: #dc3545; margin-left: 10px;">- Remove Last Premise</button>
                    <button id="defineStatementsNowButton" type="button" style="background-color: #6c757d; margin-left: 10px;">Define Statements (A, B, C...)</button>
                    
                    <div class="conclusion-area">
                        <span class="conclusion-label">Target Conclusion Form:</span>
                        <div class="conclusion-placeholder" id="conclusionPlaceholder">( K )</div> 
                    </div>
                    <div style="margin-top: 10px; padding: 10px; background-color: #f8f9fa; border-radius: 4px; font-size: 14px; color: #666;">
                        <strong>Tip:</strong> To create nested formulas like "IF A THEN (B OR C)", first drop the IF...THEN operator, then drop B and C into the empty slots that appear.
                    </div>
                    <hr style="margin: 20px 0;">
                    <button id="checkFormValidityButton" type="button">Validate Form Structure</button>
                    <div id="validityResult" style="margin-top: 10px; font-weight: bold;"></div>
                    <button id="defineStatementsButton" type="button" style="display:none; background-color: #007bff; margin-top:15px;">Next: Define Statements (A, B, C...)</button>
                </div>
            </div>
            <div id="statementDefinitionArea" style="margin-top: 20px; padding:15px; border:1px solid #ccc; background-color:#fff;">
                <h3>3. Define Your Statements</h3>
                <div id="statementInputsContainer">
                    <p style="color: #666; font-style: italic;">Click on any proposition letter (A, B, C, etc.) in your premises above to define what it represents, or click "Define Statements" to define all at once.</p>
                </div>
                <button id="submitDynamicArgumentButton" type="button" style="background-color: #28a745; margin-top:15px;">Submit Final Argument</button>
            </div>
        </div>
        <hr style="margin: 40px 0;"> 

        <div class="argument-filters">
            <h2>View Submitted Arguments</h2>
            <label for="filterClaimSelect">Filter by Claim:</label>
            <select id="filterClaimSelect"> <option value="">-- All Claims --</option> </select>
            <label for="filterStanceSelect">Filter by Stance:</label>
            <select id="filterStanceSelect"> <option value="">-- All Stances --</option> <option value="For">For</option> <option value="Against">Against</option> </select>
            <button type="button" onclick="displayArguments()">Filter Arguments</button>
        </div>

        <div class="ranking-options">
            <label for="rankingSelect">Sort Arguments By:</label>
            <select id="rankingSelect"> <option value="mostRecent">Most Recent</option> <option value="mostEndorsed">Most Endorsed</option> <option value="highestPercentage">Highest Endorsement Percentage</option> </select>
        </div>
        <div id="argumentsList"></div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/9.17.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.17.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.17.1/firebase-firestore-compat.js"></script>

    <script>
        console.log("Script 1: Starting initialization");
        
        // Initialize Firebase immediately
        const firebaseConfig = {
          apiKey: "AIzaSyBujX8q4fDGROi4PEMAEq13NrwNNlAHBzo", 
          authDomain: "crux-da4ec.firebaseapp.com", 
          projectId: "crux-da4ec", 
          storageBucket: "crux-da4ec.firebasestorage.app", 
          messagingSenderId: "230106844798", 
          appId: "1:230106844798:web:7b0230b27a9caa7d6a522f" 
        };
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        
        console.log("Script 1: Firebase initialized");

        // Define all global variables
        let selectedClaimTextForK = ''; 
        let selectedStanceForK = '';   
        let selectedArgumentForm = null; 
        let selectedClaimText = '';    
        let selectedStanceText = '';

        // Define authentication functions globally
        function register() {
            var email = document.getElementById('registerEmail').value;
            var password = document.getElementById('registerPassword').value;

            firebase.auth().createUserWithEmailAndPassword(email, password)
                .then((userCredential) => {
                    alert('Registration successful!');
                    document.getElementById('registerEmail').value = '';
                    document.getElementById('registerPassword').value = '';
                })
                .catch((error) => {
                    alert(error.message);
                });
        }

        function login() {
            var email = document.getElementById('loginEmail').value;
            var password = document.getElementById('loginPassword').value;

            firebase.auth().signInWithEmailAndPassword(email, password)
                .then((userCredential) => {
                    alert('Login successful!');
                    document.getElementById('loginEmail').value = '';
                    document.getElementById('loginPassword').value = '';
                })
                .catch((error) => {
                    alert(error.message);
                });
        }

        function logout() {
            firebase.auth().signOut().then(() => {
                alert('Logged out successfully!');
            }).catch((error) => {
                alert(error.message);
            });
        }
        
        console.log("Script 1: Auth functions defined");
        
        // Helper function to create an editable proposition bubble
        window.createEditablePropositionBubble = function(letter, text, isInPalette = false) {
            const bubble = document.createElement('span');
            bubble.className = `palette-item proposition prop-${letter.toLowerCase()}`;
            bubble.style.display = 'inline-block';
            bubble.style.position = 'relative';

// Only make it clickable if it's in a premise or conclusion area
if (!isInPalette) {
    bubble.style.cursor = letter === 'K' ? 'default' : 'pointer';
    bubble.title = letter === 'K' ? 'Main claim (cannot be edited)' : 'Click to edit statement';
} else {
    // In palette - not editable
    bubble.style.cursor = 'grab';
    bubble.title = `Drag ${letter} to a premise`;
}
            
            // Add hover effect
            bubble.style.transition = 'transform 0.2s';
            bubble.onmouseover = function() {
                this.style.transform = 'scale(1.05)';
            };
            bubble.onmouseout = function() {
                this.style.transform = 'scale(1)';
            };
            
            if (text && text.trim() !== '') {
                // Show text with proper formatting
                bubble.classList.add('with-text');
                bubble.innerHTML = `<strong>${letter}:</strong> ${text}`;
                bubble.title = `${letter}: ${text}`; // Show full text on hover
            } else {
                bubble.textContent = letter;
            }
            
            // Only add click handler if not in palette and not K
if (!isInPalette && letter !== 'K') {
    bubble.onclick = function(e) {
        e.stopPropagation();
        if (window.editPropositionText && typeof window.editPropositionText === 'function') {
            window.editPropositionText(letter);
        }
    };
}
            
            // Special styling for K to indicate it's not editable
            if (letter === 'K') {
                bubble.style.cursor = 'default';
                bubble.title = 'Main claim (cannot be edited)';
                bubble.onclick = function(e) {
                    e.stopPropagation();
                    // Do nothing for K
                };
            }
            
            return bubble;
        };
        
        // Make functions globally available for dynamicBuilderUI.js
        window.argumentWorkspace = window.argumentWorkspace || { premises: {}, conclusionAST_form: null };
        window.statementDefinitions = window.statementDefinitions || {};
        window.selectedFormulaElementInfo = null;
    </script>

    <script>
        // Validation Engine Functions (from validationEngine.js)
        /**
         * Extracts all unique propositional letters from an array of ASTs.
         */
        function extractUniquePropositions(astArray) {
            const letters = new Set();

            function traverse(node) {
                if (!node) return;

                if (node.type === 'proposition') {
                    if (node.letter) {
                        letters.add(node.letter);
                    } else {
                        console.warn("extractUniquePropositions: Proposition node encountered without a letter property.", node);
                    }
                } else if (node.type === 'operator') {
                    if (node.operand) {
                        traverse(node.operand);
                    }
                    if (node.operands) {
                        node.operands.forEach(traverse);
                    }
                }
            }

            if (Array.isArray(astArray)) {
                astArray.forEach(traverse);
            } else {
                console.warn("extractUniquePropositions: Input was not an array.", astArray);
            }
            return Array.from(letters).sort();
        }

        /**
         * Generates all possible truth assignments for a given list of proposition letters.
         */
        function generateTruthAssignments(propositionLetters) {
            const assignments = [];
            const n = propositionLetters.length;

            if (n === 0) {
                return [{}]; 
            }

            const totalAssignments = 1 << n;

            for (let i = 0; i < totalAssignments; i++) {
                const currentAssignment = {};
                for (let j = 0; j < n; j++) {
                    currentAssignment[propositionLetters[j]] = ((i >> j) & 1) === 1;
                }
                assignments.push(currentAssignment);
            }
            return assignments;
        }

        /**
         * Evaluates the truth value of a logical formula (AST) given specific truth assignments.
         */
        function evaluateFormula(formulaAST, truthAssignments) {
            if (!formulaAST || typeof formulaAST.type !== 'string') {
                console.error("evaluateFormula Error: AST node is null, undefined, or missing a 'type'. Provided:", formulaAST);
                throw new Error("Invalid AST node structure provided to evaluateFormula.");
            }

            if (formulaAST.type === 'proposition') {
                if (!formulaAST.hasOwnProperty('letter')) {
                    console.error("evaluateFormula Error: Proposition node missing 'letter'.", formulaAST);
                    throw new Error("Malformed proposition node: missing 'letter'.");
                }
                if (truthAssignments.hasOwnProperty(formulaAST.letter)) {
                    return truthAssignments[formulaAST.letter];
                } else {
                    console.warn(`evaluateFormula Warning: Truth value for proposition '${formulaAST.letter}' not found in current assignments. Defaulting to false.`);
                    return false; 
                }
            }

            if (formulaAST.type === 'operator') {
                if (!formulaAST.operator) {
                    console.error("evaluateFormula Error: Operator node missing 'operator' property.", formulaAST);
                    throw new Error("Malformed operator node: missing 'operator'.");
                }
                switch (formulaAST.operator) {
                    case 'NOT':
                        if (!formulaAST.operand) throw new Error("NOT operator missing operand.");
                        return !evaluateFormula(formulaAST.operand, truthAssignments);
                    case 'AND':
                        if (!formulaAST.operands || formulaAST.operands.length !== 2) throw new Error("AND operator requires 2 operands.");
                        return evaluateFormula(formulaAST.operands[0], truthAssignments) &&
                               evaluateFormula(formulaAST.operands[1], truthAssignments);
                    case 'OR':
                        if (!formulaAST.operands || formulaAST.operands.length !== 2) throw new Error("OR operator requires 2 operands.");
                        return evaluateFormula(formulaAST.operands[0], truthAssignments) ||
                               evaluateFormula(formulaAST.operands[1], truthAssignments);
                    case 'IFTHEN':
                        if (!formulaAST.operands || formulaAST.operands.length !== 2) throw new Error("IFTHEN operator requires 2 operands.");
                        const antecedentVal = evaluateFormula(formulaAST.operands[0], truthAssignments);
                        const consequentVal = evaluateFormula(formulaAST.operands[1], truthAssignments);
                        return !antecedentVal || consequentVal;
                    default:
                        console.error(`evaluateFormula Error: Unknown operator '${formulaAST.operator}'.`);
                        throw new Error(`Unknown operator: ${formulaAST.operator}`);
                }
            }

            console.error("evaluateFormula Error: Unknown AST node type.", formulaAST);
            throw new Error(`Unknown AST node type: ${formulaAST.type}`);
        }

        /**
         * Checks if an argument form (premises + conclusion) is logically valid.
         */
        function isArgumentFormValid(premiseASTs, conclusionAST) {
            if (!Array.isArray(premiseASTs) || !conclusionAST) {
                console.error("isArgumentFormValid Error: Invalid input. `premiseASTs` must be an array and `conclusionAST` must be provided.");
                return false; 
            }

            const allInvolvedASTs = [...premiseASTs, conclusionAST];
            const uniquePropositions = extractUniquePropositions(allInvolvedASTs);
            const truthAssignmentsList = generateTruthAssignments(uniquePropositions);

            if (truthAssignmentsList.length === 0 && uniquePropositions.length > 0) {
                console.error("isArgumentFormValid Error: Failed to generate truth assignments for identified propositions.");
                return false;
            }

            for (const currentAssignments of truthAssignmentsList) {
                let allPremisesAreTrue = true;
                if (premiseASTs.length > 0) {
                    for (const premise of premiseASTs) {
                        if (!evaluateFormula(premise, currentAssignments)) {
                            allPremisesAreTrue = false;
                            break; 
                        }
                    }
                }

                if (allPremisesAreTrue) {
                    if (!evaluateFormula(conclusionAST, currentAssignments)) {
                        console.log("Argument form is INVALID. Counterexample found with assignments:", currentAssignments);
                        return false; 
                    }
                }
            }
            return true;
        }
        
        /**
         * Checks if a set of premises is consistent (can all be true at the same time)
         */
        function arePremisesConsistent(premiseASTs) {
            if (!Array.isArray(premiseASTs) || premiseASTs.length === 0) {
                return true; // Empty set is consistent
            }

            const uniquePropositions = extractUniquePropositions(premiseASTs);
            const truthAssignmentsList = generateTruthAssignments(uniquePropositions);

            // Check if there exists at least one assignment where all premises are true
            for (const currentAssignments of truthAssignmentsList) {
                let allPremisesTrue = true;
                
                for (const premise of premiseASTs) {
                    if (!evaluateFormula(premise, currentAssignments)) {
                        allPremisesTrue = false;
                        break;
                    }
                }
                
                if (allPremisesTrue) {
                    return true; // Found an assignment where all premises are true
                }
            }
            
            return false; // No assignment makes all premises true
        }
        
        // Make function globally available
        window.arePremisesConsistent = arePremisesConsistent;
    </script>
    <script src="dynamicBuilderUI.js"></script>  

    <script>
        // Trash can functionality
        document.addEventListener('DOMContentLoaded', function() {
            console.log("Setting up trash can functionality");
            
            const trashCanArea = document.getElementById('trashCanArea');
            if (trashCanArea) {
                // Make trash can clickable to delete selected element
                trashCanArea.addEventListener('click', function(e) {
                    e.stopPropagation(); // Prevent deselection
                    console.log("Trash can clicked");
                    
                    // Check if there's a selected element
                    const selectedElement = document.querySelector('.selected-formula-element');
                    if (selectedElement) {
                        console.log("Found selected element to delete via trash click");
                        
                        // Make sure selectedFormulaElementInfo is set correctly
                        if (!window.selectedFormulaElementInfo) {
                            // Reconstruct the selection info from the element
                            window.selectedFormulaElementInfo = {
                                domElement: selectedElement,
                                premiseId: selectedElement.dataset.premiseId || '',
                                path: selectedElement.dataset.path || ''
                            };
                        }
                        
                        console.log("Current selectedFormulaElementInfo:", window.selectedFormulaElementInfo);
                        
                        // Trigger delete using the same method that works for drag
                        const deleteEvent = new KeyboardEvent('keydown', {
                            key: 'Delete',
                            code: 'Delete',
                            keyCode: 46,
                            which: 46,
                            bubbles: true,
                            cancelable: true
                        });
                        document.dispatchEvent(deleteEvent);
                    } else {
                        console.log("No element selected to delete");
                    }
                });
                
                // Prevent default drag over to allow drop
                trashCanArea.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = "move";
                    this.style.backgroundColor = '#ffcccc';
                    this.style.borderColor = '#ff0000';
                });
                
                // Remove drag over effect
                trashCanArea.addEventListener('dragleave', function() {
                    this.style.backgroundColor = '#f0f0f0';
                    this.style.borderColor = '#ccc';
                });
                
                // Handle drop on trash - properly delete the dragged element
                trashCanArea.addEventListener('drop', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log("Element dropped on trash");
                    
                    // Reset trash can appearance
                    this.style.backgroundColor = '#f0f0f0';
                    this.style.borderColor = '#ccc';
                    
                    try {
                        // Get the data from the drag event
                        const dragData = e.dataTransfer.getData('application/json');
                        if (dragData) {
                            const data = JSON.parse(dragData);
                            console.log("Dropped data:", data);
                            
                            // Check if it's a formula element being dragged
                            if (data.type === 'formula-element' && data.premiseId) {
                                console.log(`Looking for element with premise-id="${data.premiseId}" and path="${data.path || ''}"`);
                                
                                // Find all matching elements
                                const matchingElements = document.querySelectorAll(
                                    `.formula-element-wrapper[data-premise-id="${data.premiseId}"]`
                                );
                                
                                console.log(`Found ${matchingElements.length} elements with matching premise ID`);
                                
                                // Find the exact element by path
                                let elementToDelete = null;
                                matchingElements.forEach(el => {
                                    if (el.dataset.path === (data.path || '')) {
                                        elementToDelete = el;
                                        console.log("Found exact match for deletion");
                                    }
                                });
                                
                                if (elementToDelete) {
                                    console.log("Found element to delete:", elementToDelete);
                                    
                                    // Directly manipulate the selection state like dynamicBuilderUI.js does
                                    // First, clear any existing selection
                                    const currentlySelected = document.querySelector('.selected-formula-element');
                                    if (currentlySelected && currentlySelected !== elementToDelete) {
                                        currentlySelected.classList.remove('selected-formula-element');
                                    }
                                    
                                    // Select the element
                                    elementToDelete.classList.add('selected-formula-element');
                                    
                                    // Set the global selection info that dynamicBuilderUI.js uses
                                    if (!window.selectedFormulaElementInfo) {
                                        window.selectedFormulaElementInfo = {};
                                    }
                                    window.selectedFormulaElementInfo.domElement = elementToDelete;
                                    window.selectedFormulaElementInfo.premiseId = data.premiseId;
                                    window.selectedFormulaElementInfo.path = data.path || '';
                                    
                                    console.log("Set selectedFormulaElementInfo:", window.selectedFormulaElementInfo);
                                    
                                    // Now trigger deletion using the exact same approach as clicking trash
                                    setTimeout(() => {
                                        console.log("Triggering delete after setting selection");
                                        
                                        // This mimics what happens when you click the trash can
                                        const deleteEvent = new KeyboardEvent('keydown', {
                                            key: 'Delete',
                                            code: 'Delete',
                                            keyCode: 46,
                                            which: 46,
                                            bubbles: true,
                                            cancelable: true
                                        });
                                        document.dispatchEvent(deleteEvent);
                                    }, 50);
                                } else {
                                    console.error("Could not find element to delete");
                                    
                                    // Fallback: use the globally stored reference
                                    if (window.currentlyDraggedElement) {
                                        console.log("Using fallback - globally stored dragged element");
                                        window.currentlyDraggedElement.click();
                                        setTimeout(() => {
                                            const deleteEvent = new KeyboardEvent('keydown', {
                                                key: 'Delete',
                                                code: 'Delete',
                                                keyCode: 46,
                                                which: 46,
                                                bubbles: true,
                                                cancelable: true
                                            });
                                            document.dispatchEvent(deleteEvent);
                                        }, 50);
                                    }
                                }
                            } else {
                                console.log("Dropped item is not a formula element or missing premise ID");
                            }
                        } else {
                            console.log("No drag data available");
                        }
                    } catch (error) {
                        console.error("Error processing drop:", error);
                    }
                    
                    // Clean up any dragging state
                    const draggingItem = document.querySelector('.dragging');
                    if (draggingItem) {
                        draggingItem.classList.remove('dragging');
                    }
                    
                    // Clear global reference
                    window.currentlyDraggedElement = null;
                });
            }
            
            // Add a helper function to delete selected element
            window.deleteSelectedElement = function() {
                // Try to trigger the delete key event in a way that dynamicBuilderUI.js will recognize
                const activeElement = document.activeElement;
                const deleteEvent = new KeyboardEvent('keydown', {
                    key: 'Delete',
                    code: 'Delete',
                    keyCode: 46,
                    which: 46,
                    bubbles: true,
                    cancelable: true,
                    view: window,
                    ctrlKey: false,
                    altKey: false,
                    shiftKey: false,
                    metaKey: false
                });
                
                // Try dispatching on multiple targets
                if (activeElement) {
                    activeElement.dispatchEvent(deleteEvent);
                }
                document.dispatchEvent(deleteEvent);
                window.dispatchEvent(deleteEvent);
            };
            
            // Add functionality to edit proposition text
            window.editPropositionText = function(letter) {
                // Don't allow editing K
                if (letter === 'K') {
                    alert('The main claim (K) cannot be edited here. It was defined when you selected your claim.');
                    return;
                }
                
                // Show a prompt to get the new text
                const currentText = window.statementDefinitions && window.statementDefinitions[letter] ? window.statementDefinitions[letter] : '';
                const newText = prompt(`Enter the statement for ${letter}:`, currentText);
                
                if (newText !== null && newText.trim() !== '') {
                    // Store the definition
                    if (!window.statementDefinitions) {
                        window.statementDefinitions = {};
                    }
                    window.statementDefinitions[letter] = newText.trim();
                    
                    // Update all instances of this letter in the UI
                    updateAllPropositionDisplays();
                    
                    // Make the draggable elements again after re-rendering
                    setTimeout(() => {
                        const makeElementsDraggable = document.querySelector('#premisesContainer').__makeElementsDraggable;
                        if (makeElementsDraggable) {
                            makeElementsDraggable();
                        }
                    }, 100);
                }
            };
            
            // Function to update all proposition displays
            window.updateAllPropositionDisplays = function() {
                // Re-render all premises to show updated text
                if (window.argumentWorkspace && window.argumentWorkspace.premises) {
                    Object.keys(window.argumentWorkspace.premises).forEach(premiseId => {
                        if (window.renderTopLevelPremise && typeof window.renderTopLevelPremise === 'function') {
                            window.renderTopLevelPremise(premiseId);
                        }
                    });
                }
                
                // Update conclusion if it contains K
                const conclusionPlaceholder = document.getElementById('conclusionPlaceholder');
                if (conclusionPlaceholder && window.argumentWorkspace && window.argumentWorkspace.conclusionAST_form) {
                    conclusionPlaceholder.innerHTML = '';
                    
                    if (window.argumentWorkspace.conclusionAST_form.type === 'operator' && 
                        window.argumentWorkspace.conclusionAST_form.operator === 'NOT') {
                        // NOT K case
                        const notSpan = document.createElement('span');
                        notSpan.textContent = 'NOT ';
                        notSpan.style.fontStyle = 'italic';
                        notSpan.style.color = '#dc3545';
                        conclusionPlaceholder.appendChild(notSpan);
                        
                        const kBubble = createEditablePropositionBubble('K', window.statementDefinitions && window.statementDefinitions.K);
                        conclusionPlaceholder.appendChild(kBubble);
                    } else if (window.argumentWorkspace.conclusionAST_form.type === 'proposition') {
                        // Just K case
                        const kBubble = createEditablePropositionBubble('K', window.statementDefinitions && window.statementDefinitions.K);
                        conclusionPlaceholder.appendChild(kBubble);
                    }
                }
                
                // Re-make elements draggable after a short delay
                setTimeout(() => {
                    const makeElementsDraggable = document.querySelector('#premisesContainer').__makeElementsDraggable;
                    if (makeElementsDraggable) {
                        makeElementsDraggable();
                    }
                }, 100);
            };
            
            // Helper function to create an editable proposition bubble
            window.createEditablePropositionBubble = function(letter, text) {
                const bubble = document.createElement('span');
                bubble.className = `palette-item proposition prop-${letter.toLowerCase()}`;
                bubble.style.display = 'inline-block';
                bubble.style.cursor = 'pointer';
                bubble.style.position = 'relative';
                bubble.title = 'Click to edit statement';
                
                // Add hover effect
                bubble.style.transition = 'transform 0.2s';
                bubble.onmouseover = function() {
                    this.style.transform = 'scale(1.1)';
                };
                bubble.onmouseout = function() {
                    this.style.transform = 'scale(1)';
                };
                
                if (text && text.trim() !== '') {
                    // Show text instead of letter
                    bubble.textContent = text.length > 30 ? text.substring(0, 30) + '...' : text;
                    bubble.style.padding = '8px 12px';
                    bubble.style.maxWidth = '200px';
                    bubble.style.whiteSpace = 'nowrap';
                    bubble.style.overflow = 'hidden';
                    bubble.style.textOverflow = 'ellipsis';
                    bubble.title = text; // Show full text on hover
                } else {
                    bubble.textContent = letter;
                }
                
                bubble.onclick = function(e) {
                    e.stopPropagation();
                    window.editPropositionText(letter);
                };
                
                return bubble;
            };
            
            // Simple function to make all propositions editable
            window.makePropositionsEditable = function() {
                // Prevent infinite loops
                if (window.isUpdatingPropositions) return;
                window.isUpdatingPropositions = true;
                
                // Find all proposition bubbles in premises
                const allPropositions = document.querySelectorAll('#premisesContainer .palette-item.proposition, #conclusionPlaceholder .palette-item.proposition');
                
                allPropositions.forEach(prop => {
                    // Skip if already processed
                    if (prop.dataset.editableProcessed === 'true') return;
                    
                    // Get the letter (first character or from the strong tag)
                    let letter = prop.textContent.trim();
                    if (letter.includes(':')) {
                        letter = letter.split(':')[0].trim();
                    }
                    if (letter.length === 1) {
                        // Update display if we have a definition
                        if (window.statementDefinitions && window.statementDefinitions[letter]) {
                            prop.classList.add('with-text');
                            prop.innerHTML = `<strong>${letter}:</strong> ${window.statementDefinitions[letter]}`;
                            prop.title = `${letter}: ${window.statementDefinitions[letter]}`;
                        }
                        
                        // Make it clickable
                        prop.style.cursor = letter === 'K' ? 'default' : 'pointer';
                        prop.onclick = null; // Clear any existing handler
                        prop.addEventListener('click', function(e) {
                            e.stopPropagation();
                            if (letter !== 'K') {
                                window.editPropositionText(letter);
                            }
                        });
                        
                        // Mark as processed
                        prop.dataset.editableProcessed = 'true';
                    }
                });
                
                window.isUpdatingPropositions = false;
            };
            
            // Remove the MutationObserver - we'll call makePropositionsEditable manually instead
            const defineStatementsNowButton = document.getElementById('defineStatementsNowButton');
            if (defineStatementsNowButton) {
                defineStatementsNowButton.addEventListener('click', function() {
                    console.log("Define statements button clicked");
                    showStatementDefinitionPanel();
                });
            }
            
            // Function to show statement definition panel
            window.showStatementDefinitionPanel = function() {
                console.log("showStatementDefinitionPanel called");
                const statementDefArea = document.getElementById('statementDefinitionArea');
                if (!statementDefArea) {
                    console.error("statementDefinitionArea not found");
                    return;
                }
                
                // Area is already visible, but we'll populate the input fields
                const container = document.getElementById('statementInputsContainer');
                if (!container) {
                    console.error("statementInputsContainer not found");
                    return;
                }
                
                // Clear existing content
                container.innerHTML = '';
                
                // Find all used letters in the argument
                const usedLetters = new Set();
                const premises = window.argumentWorkspace ? window.argumentWorkspace.premises : {};
                
                // Function to find letters in an AST
                function findLettersInAST(ast) {
                    if (!ast) return;
                    if (ast.type === 'proposition') {
                        usedLetters.add(ast.letter);
                    } else if (ast.type === 'operator') {
                        if (ast.operand) findLettersInAST(ast.operand);
                        if (ast.operands) {
                            ast.operands.forEach(op => findLettersInAST(op));
                        }
                    }
                }
                
                // Search all premises
                Object.values(premises).forEach(premise => {
                    findLettersInAST(premise);
                });
                
                // Always include K
                usedLetters.add('K');
                
                console.log("Used letters:", Array.from(usedLetters));
                
                // Create input fields for each used letter
                const sortedLetters = Array.from(usedLetters).sort();
                sortedLetters.forEach(letter => {
                    const div = document.createElement('div');
                    div.style.marginBottom = '15px';
                    
                    const label = document.createElement('label');
                    label.textContent = `Statement ${letter}: `;
                    label.style.fontWeight = 'bold';
                    label.style.display = 'block';
                    label.style.marginBottom = '5px';
                    
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.id = `statement-${letter}`;
                    input.style.width = '100%';
                    input.style.padding = '8px';
                    input.style.border = '1px solid #ccc';
                    input.style.borderRadius = '4px';
                    
                    // Pre-fill if we already have a definition
                    if (window.statementDefinitions && window.statementDefinitions[letter]) {
                        input.value = window.statementDefinitions[letter];
                        // Also update the local scope variable used by the event handler
                        if (!definitions) {
                            var definitions = {};
                        }
                        definitions[letter] = window.statementDefinitions[letter];
                    }
                    
                    // K should be read-only
                    if (letter === 'K') {
                        input.value = window.mainClaimText || '';
                        input.readOnly = true;
                        input.style.backgroundColor = '#f0f0f0';
                    }
                    
                    // Update statementDefinitions when user types
                    input.addEventListener('input', function() {
                        if (!window.statementDefinitions) {
                            window.statementDefinitions = {};
                        }
                        window.statementDefinitions[letter] = this.value.trim();
                        // Also update local definitions object
                        definitions[letter] = this.value.trim();
                        // Update all proposition displays
                        if (window.updateAllPropositionDisplays) {
                            window.updateAllPropositionDisplays();
                        }
                    });
                    
                    div.appendChild(label);
                    div.appendChild(input);
                    container.appendChild(div);
                });
                
                // Add instruction text at the bottom
                const instructionP = document.createElement('p');
                instructionP.style.color = '#666';
                instructionP.style.fontStyle = 'italic';
                instructionP.style.marginTop = '10px';
                instructionP.textContent = 'You can also click directly on any letter in your premises above to define it.';
                container.appendChild(instructionP);
                
                // Scroll to the definition area
                statementDefArea.scrollIntoView({ behavior: 'smooth', block: 'center' });
            };
            
            // Handle submit button for dynamic arguments
            const submitDynamicArgumentButton = document.getElementById('submitDynamicArgumentButton');
            console.log("Looking for submit button:", submitDynamicArgumentButton);
            if (submitDynamicArgumentButton) {
                console.log("Submit button found, adding click listener");
                submitDynamicArgumentButton.addEventListener('click', function() {
                    console.log("Submit dynamic argument clicked");
                    
                    // Collect all statement definitions
                    const inputs = document.querySelectorAll('#statementInputsContainer input');
                    let allFilled = true;
                    
                    // Make sure we have the global statementDefinitions object
                    if (!window.statementDefinitions) {
                        window.statementDefinitions = {};
                    }
                    
                    inputs.forEach(input => {
                        const letter = input.id.replace('statement-', '');
                        window.statementDefinitions[letter] = input.value.trim();
                        if (!window.statementDefinitions[letter] && letter !== 'K') {
                            allFilled = false;
                        }
                    });
                    
                    console.log("Global statementDefinitions:", window.statementDefinitions);
                    
                    if (!allFilled) {
                        alert('Please define all statements before submitting.');
                        return;
                    }
                    
                    // Prepare argument for submission
                    const argumentTitle = document.getElementById('dynamicArgumentTitle').value || 'Untitled Argument';
                    
                    // Get all premises ASTs for consistency check
                    const premises = window.argumentWorkspace ? window.argumentWorkspace.premises : {};
                    const premiseASTs = [];
                    Object.keys(premises).sort().forEach(premiseId => {
                        if (premises[premiseId] !== null && premises[premiseId] !== undefined) {
                            premiseASTs.push(premises[premiseId]);
                        }
                    });
                    
                    // Check validity and consistency before submission
                    const conclusionAST = window.argumentWorkspace && window.argumentWorkspace.conclusionAST_form 
                        ? window.argumentWorkspace.conclusionAST_form 
                        : { type: 'proposition', letter: 'K' };
                    
                    // Check consistency
                    const isConsistent = arePremisesConsistent(premiseASTs);
                    if (!isConsistent) {
                        alert('Cannot submit argument: The premises are INCONSISTENT (they cannot all be true at the same time). Please revise your argument to ensure consistency.');
                        return;
                    }
                    
                    // Check validity
                    const isValid = isArgumentFormValid(premiseASTs, conclusionAST);
                    if (!isValid) {
                        alert('Cannot submit argument: The argument form is INVALID. There exists a case where all premises are true but the conclusion is false. Please revise your argument to ensure validity.');
                        return;
                    }
                    
                    // Convert premises to readable format
                    const argumentLines = [];
                    const premiseURLs = {};
                    
                    // Function to convert AST to readable string - using global statementDefinitions
                    function astToReadableString(ast) {
                        if (!ast) return '[empty]';
                        if (ast.type === 'proposition') {
                            const text = window.statementDefinitions[ast.letter] || `[${ast.letter}]`;
                            return `<strong>${ast.letter}</strong>: ${text}`;
                        } else if (ast.type === 'operator') {
                            if (ast.operator === 'NOT') {
                                return `NOT (${astToReadableString(ast.operand)})`;
                            } else if (ast.operator === 'IFTHEN') {
                                return `IF (${astToReadableString(ast.operands[0])}) THEN (${astToReadableString(ast.operands[1])})`;
                            } else {
                                return `(${astToReadableString(ast.operands[0])}) ${ast.operator} (${astToReadableString(ast.operands[1])})`;
                            }
                        }
                        return '[unknown]';
                    }
                    
                    // Add each premise and collect URLs
                    Object.keys(premises).sort().forEach((premiseId, index) => {
                        if (premises[premiseId]) {
                            const line = astToReadableString(premises[premiseId]);
                            console.log(`Premise ${premiseId} converted to:`, line);
                            argumentLines.push(line);
                            
                            // Get the URL for this premise
                            const urlInput = document.getElementById(`premise-${premiseId}-url`);
                            if (urlInput && urlInput.value.trim()) {
                                let url = urlInput.value.trim();
                                
                                // Add protocol if missing
                                if (!url.match(/^https?:\/\//i)) {
                                    url = 'https://' + url;
                                }
                                
                                // Basic URL validation
                                try {
                                    new URL(url); // This will throw if invalid
                                    premiseURLs[index] = url;
                                    console.log(`Premise ${premiseId} has URL:`, url);
                                } catch (e) {
                                    console.error(`Invalid URL for premise ${premiseId}:`, url);
                                    alert(`Invalid URL for Premise ${premiseId}: ${urlInput.value.trim()}`);
                                }
                            }
                        }
                    });
                    
                    // Add conclusion
                    const conclusion = window.argumentWorkspace && window.argumentWorkspace.conclusionAST_form 
                        ? astToReadableString(window.argumentWorkspace.conclusionAST_form)
                        : `<strong>K</strong>: ${window.statementDefinitions.K || '[K]'}`;
                    console.log("Conclusion converted to:", conclusion);
                    argumentLines.push(`Therefore: ${conclusion}`);
                    
                    console.log("Final argumentLines being submitted:", argumentLines);
                    console.log("Premise URLs being submitted:", premiseURLs);
                    
                    // Submit to Firebase
                    const user = firebase.auth().currentUser;
                    if (!user) {
                        alert('You must be logged in to submit an argument.');
                        return;
                    }
                    
                    const argumentData = {
                        title: argumentTitle,
                        claimText: window.mainClaimText,
                        stanceText: selectedStanceForK,
                        argumentLines: argumentLines,
                        premiseURLs: premiseURLs,
                        endorsements: 0,
                        disagreements: 0,
                        endorsementPercentage: 0,
                        userId: user.uid,
                        userEmail: user.email,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    };
                    
                    db.collection('arguments').add(argumentData)
                        .then(() => {
                            alert('Argument submitted successfully!');
                            // Reset the form
                            location.reload();
                        })
                        .catch((error) => {
                            console.error('Error submitting argument:', error);
                            alert('Error submitting argument: ' + error.message);
                        });
                });
            }
            
            // Handle validation button
            const checkFormValidityButton = document.getElementById('checkFormValidityButton');
            if (checkFormValidityButton) {
                checkFormValidityButton.addEventListener('click', function() {
                    console.log("Validate button clicked");
                    
                    // Get all premises ASTs
                    const premiseASTs = [];
                    const premises = window.argumentWorkspace ? window.argumentWorkspace.premises : {};
                    
                    // Debug logging
                    console.log("All premises in workspace:", premises);
                    
                    Object.keys(premises).sort().forEach(premiseId => {
                        if (premises[premiseId] !== null && premises[premiseId] !== undefined) {
                            console.log(`Premise ${premiseId}:`, JSON.stringify(premises[premiseId]));
                            premiseASTs.push(premises[premiseId]);
                        } else {
                            console.log(`Premise ${premiseId}: null or undefined (skipping)`);
                        }
                    });
                    
                    // Get conclusion AST
                    const conclusionAST = window.argumentWorkspace && window.argumentWorkspace.conclusionAST_form 
                        ? window.argumentWorkspace.conclusionAST_form 
                        : { type: 'proposition', letter: 'K' };
                    
                    // Debug: Let's see exactly what we're validating
                    console.log("=== VALIDATION DEBUG ===");
                    console.log("Number of premises:", premiseASTs.length);
                    premiseASTs.forEach((premise, index) => {
                        console.log(`Premise ${index + 1}:`, JSON.stringify(premise, null, 2));
                    });
                    console.log("Conclusion:", JSON.stringify(conclusionAST, null, 2));
                    console.log("======================");
                    
                    // Check if we have the validation function
                    if (typeof isArgumentFormValid === 'function') {
                        // First check consistency
                        const isConsistent = arePremisesConsistent(premiseASTs);
                        
                        if (!isConsistent) {
                            const resultDiv = document.getElementById('validityResult');
                            if (resultDiv) {
                                resultDiv.innerHTML = '<span style="color: orange;"> The premises are INCONSISTENT! They cannot all be true at the same time.</span>';
                                resultDiv.innerHTML += '<br><span style="color: #666; font-size: 14px;">An argument with inconsistent premises is vacuously valid but not useful.</span>';
                            }
                            return;
                        }
                        
                        const isValid = isArgumentFormValid(premiseASTs, conclusionAST);
                        
                        const resultDiv = document.getElementById('validityResult');
                        if (resultDiv) {
                            if (isValid) {
                                resultDiv.innerHTML = '<span style="color: green;"> This argument form is VALID!</span>';
                            } else {
                                resultDiv.innerHTML = '<span style="color: red;"> This argument form is INVALID. There exists a case where all premises are true but the conclusion is false.</span>';
                                
                                // Let's also show a counterexample
                                const usedLetters = new Set();
                                
                                // Find all letters in premises and conclusion
                                function findLetters(ast) {
                                    if (!ast) return;
                                    if (ast.type === 'proposition') {
                                        usedLetters.add(ast.letter);
                                    } else if (ast.type === 'operator') {
                                        if (ast.operand) findLetters(ast.operand);
                                        if (ast.operands) ast.operands.forEach(findLetters);
                                    }
                                }
                                
                                premiseASTs.forEach(findLetters);
                                findLetters(conclusionAST);
                                
                                // Try to find a counterexample
                                const letters = Array.from(usedLetters).sort();
                                const totalAssignments = Math.pow(2, letters.length);
                                
                                // Check if we have access to evaluateFormula
                                if (typeof evaluateFormula === 'function') {
                                    for (let i = 0; i < totalAssignments; i++) {
                                        const assignment = {};
                                        for (let j = 0; j < letters.length; j++) {
                                            assignment[letters[j]] = ((i >> j) & 1) === 1;
                                        }
                                        
                                        // Check if all premises are true
                                        let allPremisesTrue = premiseASTs.every(premise => 
                                            evaluateFormula(premise, assignment)
                                        );
                                        
                                        if (allPremisesTrue && !evaluateFormula(conclusionAST, assignment)) {
                                            // Found a counterexample
                                            const counterexampleText = letters.map(letter => 
                                                `${letter}=${assignment[letter] ? 'true' : 'false'}`
                                            ).join(', ');
                                            
                                            resultDiv.innerHTML += `<br><span style="color: #666; font-size: 14px;">Counterexample: ${counterexampleText}</span>`;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        alert('Validation engine not loaded properly.');
                    }
                });
            }
            
            // Add functionality to remove premises
            const removePremiseButton = document.getElementById('removePremiseButton');
            if (removePremiseButton) {
                removePremiseButton.addEventListener('click', function() {
                    const premisesContainer = document.getElementById('premisesContainer');
                    const allPremiseSlots = premisesContainer.querySelectorAll('.premise-slot');
                    
                    if (allPremiseSlots.length <= 2) {
                        alert('You must have at least 2 premises.');
                        return;
                    }
                    
                    // Remove the last premise
                    const lastPremiseNum = allPremiseSlots.length;
                    const lastPremiseSlot = document.getElementById(`premise-${lastPremiseNum}-slot-container`);
                    
                    if (lastPremiseSlot) {
                        lastPremiseSlot.remove();
                        // Also remove from argumentWorkspace
                        if (window.argumentWorkspace && window.argumentWorkspace.premises) {
                            delete window.argumentWorkspace.premises[lastPremiseNum.toString()];
                        }
                    }
                });
            }
            const premisesContainer = document.getElementById('premisesContainer');
            if (premisesContainer) {
                const makeElementsDraggable = function() {
                    const formulaElements = premisesContainer.querySelectorAll('.formula-element-wrapper');
                    console.log(`Making ${formulaElements.length} formula elements draggable`);
                    
                    formulaElements.forEach(element => {
                        if (!element.hasAttribute('draggable')) {
                            element.setAttribute('draggable', 'true');
                            element.style.cursor = 'move';
                            
                            element.addEventListener('dragstart', function(e) {
                                e.stopPropagation();
                                this.classList.add('dragging');
                                this.style.opacity = '0.5';
                                
                                // Store the element info in dataTransfer
                                const premiseId = this.dataset.premiseId || '';
                                const path = this.dataset.path || '';
                                const dragData = {
                                    type: 'formula-element',
                                    premiseId: premiseId,
                                    path: path
                                };
                                
                                console.log("Dragging element:", dragData);
                                console.log("Element dataset:", this.dataset);
                                e.dataTransfer.setData('application/json', JSON.stringify(dragData));
                                e.dataTransfer.setData('text/plain', `${premiseId}|${path}`); // Backup format
                                e.dataTransfer.effectAllowed = 'move';
                                
                                // Store reference globally as backup
                                window.currentlyDraggedElement = this;
                                
                                // Also click to select it
                                this.click();
                            });
                            
                            element.addEventListener('dragend', function(e) {
                                this.classList.remove('dragging');
                                this.style.opacity = '';
                            });
                        }
                    });
                };
                
                // Store the function reference on the container element
                premisesContainer.__makeElementsDraggable = makeElementsDraggable;
                
                // Initial setup
                setTimeout(makeElementsDraggable, 100);
                
                // Watch for changes
                const observer = new MutationObserver(function(mutations) {
                    makeElementsDraggable();
                });
                
                observer.observe(premisesContainer, {
                    childList: true,
                    subtree: true
                });
            }
        });
    </script>

    <script>
        console.log("Script 2: Starting main script");
        
        // Complete claims data
        const claimsByCategory = {
            "Politics & Governance": { 
                "Electoral Systems & Reform": [ { value: 'pol_esr_001', text: 'Compulsory voting should be implemented in all democratic nations.' }, { value: 'pol_esr_002', text: 'Lowering the voting age to 16 would enhance civic engagement.' }, { value: 'pol_esr_003', text: 'Proportional representation electoral systems are fairer than first-past-the-post systems.' }, { value: 'pol_esr_004', text: 'Strict campaign finance limits are essential for reducing political corruption.' }, { value: 'pol_esr_005', text: 'Online voting systems are secure enough for widespread use in national elections.' } ],
                "Civil Rights & Liberties": [ { value: 'pol_crl_001', text: 'Freedom of speech should have no limitations, even for hate speech.' }, { value: 'pol_crl_002', text: 'Government surveillance of citizens is justified for national security purposes.' }, { value: 'pol_crl_003', text: 'The right to privacy is more important than the needs of law enforcement.' }, { value: 'pol_crl_004', text: 'Affirmative action policies are necessary to address historical injustices.' }, { value: 'pol_crl_005', text: 'Citizens should have the right to bear arms with minimal restrictions.' } ],
                "Political Ideologies": [ { value: 'pol_pid_001', text: 'Socialism offers a more equitable societal structure than capitalism.' }, { value: 'pol_pid_002', text: 'Libertarianism provides the optimal balance of individual freedom and limited government.' }, { value: 'pol_pid_003', text: 'Nationalism is a detrimental force in international relations.' }, { value: 'pol_pid_004', text: 'A global governing body would be beneficial for humanity.' } ]
            },
            "Technology & Innovation": { 
                "Artificial Intelligence": [ { value: 'tec_ai_001', text: 'The development of artificial general intelligence (AGI) poses an existential threat to humanity.' }, { value: 'tec_ai_002', text: 'AI will create more jobs than it eliminates in the long run.' }, { value: 'tec_ai_003', text: 'Governments should heavily regulate AI development to prevent misuse.' }, { value: 'tec_ai_004', text: 'AI-driven decision-making in areas like criminal justice can be free of human bias.' }, { value: 'tec_ai_005', text: 'Consciousness can emerge in advanced AI systems.' } ],
                "Internet & Digital Society": [ { value: 'tec_ids_001', text: 'Social media platforms have a net negative impact on society.' }, { value: 'tec_ids_002', text: 'Net neutrality is essential for a fair and open internet.' }, { value: 'tec_ids_003', text: 'Online anonymity does more harm than good.' }, { value: 'tec_ids_004', text: 'The spread of misinformation online can only be solved by platform censorship.' }, { value: 'tec_ids_005', text: 'Decentralized web technologies (Web3) will fundamentally change the internet.' } ],
                "Biotechnology & Futurism": [ { value: 'tec_bio_001', text: 'Genetic engineering of humans should be pursued to enhance capabilities.' }, { value: 'tec_bio_002', text: 'Cryonics (freezing bodies for future revival) is a plausible path to life extension.' }, { value: 'tec_bio_003', text: 'Widespread adoption of lab-grown meat is inevitable and beneficial.' }, { value: 'tec_bio_004', text: 'Human colonization of other planets is essential for the long-term survival of the species.' } ]
            },
            "Environment & Sustainability": { 
                "Climate Change": [ { value: 'env_cc_001', text: 'Global carbon emissions must reach net-zero by 2050 to avoid catastrophic climate change.' }, { value: 'env_cc_002', text: 'Individual lifestyle changes are more critical than government policies in combating climate change.' }, { value: 'env_cc_003', text: 'Nuclear power is a necessary component of a low-carbon energy future.' }, { value: 'env_cc_004', text: 'Carbon capture technologies are a viable solution to significantly reduce atmospheric CO2.' }, { value: 'env_cc_005', text: 'The economic costs of transitioning to a green economy outweigh the benefits.' } ],
                "Conservation & Resources": [ { value: 'env_cr_001', text: 'Protecting biodiversity should take precedence over economic development.' }, { value: 'env_cr_002', text: 'Freshwater will become a more significant source of conflict than oil in the future.' }, { value: 'env_cr_003', text: 'Trophy hunting can be a legitimate tool for wildlife conservation funding.' }, { value: 'env_cr_004', text: 'Humans have a moral obligation to prevent the extinction of any species.' } ],
                "Sustainable Living": [ { value: 'env_sl_001', text: 'A global shift to a primarily plant-based diet is essential for environmental sustainability.' }, { value: 'env_sl_002', text: 'Minimalism as a lifestyle is a key to reducing environmental impact.' }, { value: 'env_sl_003', text: 'Circular economies are the only long-term solution to resource depletion.' }, { value: 'env_sl_004', text: 'Consumerism is inherently incompatible with environmental sustainability.' } ]
            },
            "Culture & Society": { 
                "Media & Information": [ { value: 'cul_mi_001', text: 'Traditional news media is inherently biased and no longer trustworthy.' }, { value: 'cul_mi_002', text: 'Citizen journalism does more to inform the public than professional journalism.' }, { value: 'cul_mi_003', text: 'Fact-checking initiatives are effective at combating misinformation.' }, { value: 'cul_mi_004', text: 'The 24/7 news cycle has a detrimental effect on public discourse and mental health.' }, { value: 'cul_mi_005', text: 'Algorithms used by social media platforms create echo chambers that polarize society.' } ],
                "Social Norms & Traditions": [ { value: 'cul_snt_001', text: 'Traditional gender roles are oppressive and should be dismantled entirely.' }, { value: 'cul_snt_002', text: 'Cultural appropriation is harmful and should always be avoided.' }, { value: 'cul_snt_003', text: 'Monogamy is an outdated concept for modern relationships.' }, { value: 'cul_snt_004', text: 'Societal pressure to conform to beauty standards is a primary source of unhappiness.' }, { value: 'cul_snt_005', text: 'Cancel culture is a necessary tool for social accountability.' } ],
                "Arts & Humanities": [ { value: 'cul_ah_001', text: 'Government funding for the arts is a waste of taxpayer money.' }, { value: 'cul_ah_002', text: 'Classical art forms (e.g., opera, ballet) are irrelevant to contemporary society.' }, { value: 'cul_ah_003', text: 'The primary purpose of art should be to provoke social or political change.' }, { value: 'cul_ah_004', text: 'Video games should be considered a legitimate art form on par with film or literature.' }, { value: 'cul_ah_005', text: 'Studying humanities is essential for developing critical thinking and empathy.' } ],
                "Religion & Spirituality": [ { value: 'cul_rs_001', text: 'Organized religion has a net negative impact on human progress.' }, { value: 'cul_rs_002', text: 'Religious belief is incompatible with a scientific worldview.' }, { value: 'cul_rs_003', text: 'Secularism in government is the only way to ensure religious freedom for all.' }, { value: 'cul_rs_004', text: 'Spiritual experiences are valid even without a belief in a deity.' }, { value: 'cul_rs_005', text: 'Religious texts should be interpreted literally.' } ]
            },
            "Health & Wellness": { 
                "Healthcare Systems & Policy": [ { value: 'hea_hsp_001', text: 'Universal healthcare, funded by taxes, is the most ethical way to provide medical services.' }, { value: 'hea_hsp_002', text: 'Pharmaceutical companies should have their drug prices heavily regulated by the government.' }, { value: 'hea_hsp_003', text: 'Preventive healthcare should receive significantly more funding than treatment-focused care.' }, { value: 'hea_hsp_004', text: 'Individuals should have the right to refuse any mandatory medical treatment, including vaccines.' }, { value: 'hea_hsp_005', text: 'The privatization of healthcare leads to better quality and innovation.' } ],
                "Medical Ethics & Research": [ { value: 'hea_mer_001', text: 'Animal testing for medical research is a necessary evil.' }, { value: 'hea_mer_002', text: 'Human cloning, even for therapeutic purposes, is unethical.' }, { value: 'hea_mer_003', text: 'Physician-assisted suicide should be a legal option for terminally ill patients.' }, { value: 'hea_mer_004', text: 'Placebos should never be used in clinical trials if an existing treatment is available.' }, { value: 'hea_mer_005', text: 'Genetic data from individuals should be freely available for medical research without explicit consent for each use.' } ],
                "Nutrition & Diet": [ { value: 'hea_nd_006', text: 'Government regulation of unhealthy foods (e.g., sugar tax) is an infringement on personal liberty.' }, { value: 'hea_nd_007', text: 'Most dietary supplements offer no significant health benefits for the average person.' }, { value: 'hea_nd_008', text: 'Intermittent fasting is a superior method for weight loss and health compared to traditional calorie restriction.' } ],
                "Mental Health & Psychiatry": [ { value: 'hea_mhp_006', text: 'Over-diagnosis is a significant problem in modern psychiatry.' }, { value: 'hea_mhp_007', text: 'Psychedelic-assisted therapy should be legalized for treating mental health conditions.' }, { value: 'hea_mhp_008', text: 'Social media usage is a primary driver of increasing rates of anxiety and depression in youth.' } ]
            },
            "History": { 
                "Ancient Civilizations": [ { value: 'his_ac_006', text: 'The Roman Empire\'s fall was primarily due to internal decay rather than external pressures.' }, { value: 'his_ac_007', text: 'Ancient Athens provided a better model for democracy than modern representative democracies.' } ],
                "Modern Era": [ { value: 'his_me_006', text: 'The outcome of World War I inevitably led to World War II.' }, { value: 'his_me_007', text: 'The Enlightenment had a greater impact on shaping the modern world than the Renaissance.' } ],
                "Historical Interpretation": [ { value: 'his_hi_001', text: 'History is always written by the victors, making objective truth unattainable.' }, { value: 'his_hi_002', text: 'Present-day moral standards should not be used to judge historical figures.' }, { value: 'his_hi_003', text: 'Studying history is crucial for understanding and solving contemporary problems.' } ]
            },
            "Philosophy & Ethics": { 
                "Applied Ethics": [ { value: 'phi_ae_001', text: 'Vegetarianism or veganism is a moral imperative.' }, { value: 'phi_ae_002', text: 'Capitalism is inherently an unethical system.' }, { value: 'phi_ae_003', text: 'Artificial intelligence should be granted rights if it achieves sentience.' }, { value: 'phi_ae_004', text: 'Whistleblowing is always ethically justified when exposing wrongdoing, regardless of consequences.' } ],
                "Political Philosophy": [ { value: 'phi_pp_001', text: 'The primary role of the state is to ensure the welfare of its citizens.' }, { value: 'phi_pp_002', text: 'Anarchism is a viable and desirable political system.' }, { value: 'phi_pp_003', text: 'Individuals have a moral obligation to disobey unjust laws.' } ]
            },
            "Economics & Business": {
                "Economic Systems": [ { value: 'eco_es_001', text: 'Pure free-market capitalism leads to the greatest overall prosperity.' }, { value: 'eco_es_002', text: 'A universal basic income (UBI) is a feasible solution to poverty and automation-driven job loss.' }, { value: 'eco_es_003', text: 'Key industries like energy and healthcare should be nationalized.' }, { value: 'eco_es_004', text: 'Economic growth should no longer be the primary goal of developed nations.' } ],
                "Labor & Employment": [ { value: 'eco_le_001', text: 'Strong labor unions are essential for protecting workers\' rights and wages.' }, { value: 'eco_le_002', text: 'The gig economy exploits workers more than it empowers them.' }, { value: 'eco_le_003', text: 'A federally mandated minimum wage harms employment rates for low-skilled workers.' }, { value: 'eco_le_004', text: 'Automation will inevitably lead to widespread, long-term unemployment.' } ],
                "Global Trade & Finance": [ { value: 'eco_gtf_001', text: 'Protectionist trade policies ultimately harm the domestic economy.' }, { value: 'eco_gtf_002', text: 'Cryptocurrencies will eventually replace traditional fiat currencies.' }, { value: 'eco_gtf_003', text: 'The World Bank and IMF do more harm than good in developing nations.' } ],
                "Corporate Ethics & Responsibility": [ { value: 'eco_cer_001', text: 'The sole responsibility of a business is to maximize profits for its shareholders.' }, { value: 'eco_cer_002', text: 'Corporations should be legally mandated to prioritize environmental and social impacts.' }, { value: 'eco_cer_003', text: 'Executive compensation in large corporations is excessively high and unjustified.' } ]
            },
            "Education System": { 
                "Curriculum & Pedagogy": [ { value: 'edu_cp_001', text: 'Standardized curricula hinder creativity and critical thinking in students.' }, { value: 'edu_cp_002', text: 'Education should focus more on vocational skills than liberal arts.' }, { value: 'edu_cp_003', text: 'Inquiry-based learning is more effective than direct instruction for long-term knowledge retention.' }, { value: 'edu_cp_004', text: 'Sex education should be comprehensive and mandatory from an early age in schools.' } ],
                "Assessment & Standards": [ { value: 'edu_as_001', text: 'Standardized testing is an accurate and fair measure of student ability and school performance.' }, { value: 'edu_as_002', text: 'Letter grades should be abolished in favor of more holistic assessment methods.' }, { value: 'edu_as_003', text: 'Social promotion (advancing students regardless of academic performance) is detrimental to education.' } ],
                "Higher Education": [ { value: 'edu_he_001', text: 'College education in [Country - e.g., the US] is unaffordable for the average person and needs radical reform.' }, { value: 'edu_he_002', text: 'A university degree is no longer a guarantee of a successful career.' }, { value: 'edu_he_003', text: 'Tenure for university professors should be abolished.' }, { value: 'edu_he_004', text: 'Online universities can provide an education of equal quality to traditional brick-and-mortar institutions.' } ],
                "Role of Technology in Education": [ { value: 'edu_te_001', text: 'Replacing textbooks with tablets or laptops in K-12 education is beneficial for learning.' }, { value: 'edu_te_002', text: 'AI tutors can be more effective than human tutors for certain subjects.' }, { value: 'edu_te_003', text: 'Increased screen time due to educational technology is harming childrens development.' } ]
            }
        };
        
        console.log("Script 2: Claims data defined");

        // Function to set up the dynamic builder
        function setupDynamicBuilderExternal(claimText, stance, claimLetter) {
            console.log("LOG: setupDynamicBuilderExternal called with:", claimText, stance, claimLetter);
            
            // Store the claim text globally for later use
            window.mainClaimText = claimText;
            if (!window.statementDefinitions) {
                window.statementDefinitions = {};
            }
            window.statementDefinitions.K = claimText;
            
            // Initialize argumentWorkspace if it doesn't exist
            if (!window.argumentWorkspace) {
                window.argumentWorkspace = {
                    premises: {},
                    conclusionAST_form: null
                };
            }
            
            // Set the conclusion AST based on stance
            if (stance === 'Against') {
                window.argumentWorkspace.conclusionAST_form = {
                    type: 'operator',
                    operator: 'NOT',
                    operand: { type: 'proposition', letter: 'K', colorClass: 'prop-k' }
                };
            } else {
                window.argumentWorkspace.conclusionAST_form = {
                    type: 'proposition',
                    letter: 'K',
                    colorClass: 'prop-k'
                };
            }
            
            // Update the conclusion placeholder
            const conclusionPlaceholder = document.getElementById('conclusionPlaceholder');
            if (conclusionPlaceholder) {
                conclusionPlaceholder.innerHTML = ''; // Clear existing content
                
                if (stance === 'Against') {
                    // Create NOT text
                    const notSpan = document.createElement('span');
                    notSpan.textContent = 'NOT ';
                    notSpan.style.fontStyle = 'italic';
                    notSpan.style.color = '#dc3545';
                    conclusionPlaceholder.appendChild(notSpan);
                    
                    // Create K bubble with text
                    const kBubble = window.createEditablePropositionBubble ? 
                        window.createEditablePropositionBubble('K', claimText) : 
                        document.createElement('span');
                    if (!window.createEditablePropositionBubble) {
                        kBubble.className = 'palette-item proposition prop-k';
                        kBubble.textContent = 'K';
                        kBubble.style.display = 'inline-block';
                        kBubble.style.cursor = 'default';
                    }
                    conclusionPlaceholder.appendChild(kBubble);
                } else {
                    // Just create K bubble with text
                    const kBubble = window.createEditablePropositionBubble ? 
                        window.createEditablePropositionBubble('K', claimText) : 
                        document.createElement('span');
                    if (!window.createEditablePropositionBubble) {
                        kBubble.className = 'palette-item proposition prop-k';
                        kBubble.textContent = 'K';
                        kBubble.style.display = 'inline-block';
                        kBubble.style.cursor = 'default';
                    }
                    conclusionPlaceholder.appendChild(kBubble);
                }
            }
            
            // Update the display elements
            const displayMainClaimK = document.getElementById('displayMainClaimK');
            if (displayMainClaimK) {
                displayMainClaimK.textContent = claimText;
            }
            
            const displayStanceOnK = document.getElementById('displayStanceOnK');
            if (displayStanceOnK) {
                displayStanceOnK.textContent = stance.toUpperCase();
            }
            
            console.log("LOG: Dynamic builder setup completed");
            
            // Make sure statement definition area is visible
            const statementDefArea = document.getElementById('statementDefinitionArea');
            if (statementDefArea) {
                statementDefArea.style.display = 'block';
            }
            
            // Start making propositions editable
            setTimeout(() => {
                if (window.makePropositionsEditable) {
                    window.makePropositionsEditable();
                }
            }, 100);
        }

        // All the main functions
        function initializeAndShowDynamicBuilder() {
            const claimSelect = document.getElementById('claimSelect');
            const stanceSelect = document.getElementById('stanceSelect');

            if (!claimSelect || claimSelect.value === "") {
                alert("Please select the Main Claim (K) you will argue about from the dropdowns.");
                if (claimSelect) claimSelect.focus(); 
                return;
            }
            if (!stanceSelect || stanceSelect.value === "") {
                alert("Please select your Stance on this claim from the dropdowns.");
                if (stanceSelect) stanceSelect.focus(); 
                return;
            }

            selectedClaimTextForK = claimSelect.options[claimSelect.selectedIndex].text;
            selectedStanceForK = stanceSelect.value; 

            console.log(`LOG: Initializing dynamic builder. Claim (K): "${selectedClaimTextForK}", Stance: ${selectedStanceForK}`);

            const displayMainClaimKEl = document.getElementById('displayMainClaimK');
            if (displayMainClaimKEl) displayMainClaimKEl.textContent = selectedClaimTextForK;
            const displayStanceOnKEl = document.getElementById('displayStanceOnK');
            if (displayStanceOnKEl) displayStanceOnKEl.textContent = selectedStanceForK.toUpperCase();

            if (typeof setupDynamicBuilderExternal === "function") {
                setupDynamicBuilderExternal(selectedClaimTextForK, selectedStanceForK, 'K'); 
                
                const claimSetupForm = document.getElementById('claimSetupForm');
                if(claimSetupForm) claimSetupForm.style.display = 'none';

                const dynamicBuilderSection = document.getElementById('dynamicArgumentBuilder');
                if (dynamicBuilderSection) dynamicBuilderSection.style.display = 'block'; 
                
                console.log("LOG: Dynamic builder setup initiated and should be visible.");
            } else {
                console.error("LOG: CRITICAL - setupDynamicBuilderExternal function not found!");
                alert("Error: Could not initialize the dynamic argument builder.");
            }
        }

        function displayArguments() {
            const argumentsList = document.getElementById('argumentsList');
            if (!argumentsList) return;
            
            argumentsList.innerHTML = '';

            const rankingMethod = document.getElementById('rankingSelect').value;
            const claimFilter = document.getElementById('filterClaimSelect').value;
            const stanceFilter = document.getElementById('filterStanceSelect').value;
            const user = firebase.auth().currentUser;

            let query = db.collection('arguments');

            // Apply filters
            if (claimFilter) {
                query = query.where('claimText', '==', claimFilter);
            }
            if (stanceFilter) {
                query = query.where('stanceText', '==', stanceFilter);
            }

            // Add ordering
            if (rankingMethod === 'mostEndorsed') {
                query = query.orderBy('endorsements', 'desc');
            } else if (rankingMethod === 'highestPercentage') {
                query = query.orderBy('endorsementPercentage', 'desc');
            } else { // mostRecent
                query = query.orderBy('createdAt', 'desc');
            }

            // Fetch and render arguments
            query.get().then((querySnapshot) => {
                querySnapshot.forEach((doc) => {
                    const argumentObj = doc.data();
                    argumentObj.id = doc.id;

                    // Render argument
                    const argumentDiv = document.createElement('div');
                    argumentDiv.className = 'argument';
                    argumentDiv.dataset.id = argumentObj.id;

                    const argumentHeader = document.createElement('div');
                    argumentHeader.className = 'argument-header';

                    const stanceIcon = document.createElement('i');
                    stanceIcon.className = 'argument-icon ' + (argumentObj.stanceText === 'For' ? 'fas fa-thumbs-up' : 'fas fa-thumbs-down');

                    const argumentTitle = document.createElement('h3');
                    argumentTitle.className = 'argument-title';
                    argumentTitle.textContent = argumentObj.title;

                    argumentHeader.appendChild(stanceIcon);
                    argumentHeader.appendChild(argumentTitle);

                    const claimElement = document.createElement('p');
                    claimElement.innerHTML = `<strong>Claim (${argumentObj.stanceText}):</strong> ${argumentObj.claimText}`;
                    claimElement.style.marginTop = '15px';
                    claimElement.style.fontSize = '20px';
                    claimElement.style.color = '#555';

                    const argumentContentDiv = document.createElement('div');
                    argumentContentDiv.className = 'argument-content';

                    const ol = document.createElement('ol');

                    argumentObj.argumentLines.forEach((line, index) => {
                        const li = document.createElement('li');

                        const premiseText = document.createElement('span');
                        premiseText.className = 'premise-text';
                        premiseText.innerHTML = line;

                        li.appendChild(premiseText);

                        // Add URL next to the premise if available
                        if (argumentObj.premiseURLs && argumentObj.premiseURLs[index]) {
                            const urlLink = document.createElement('a');
                            urlLink.href = argumentObj.premiseURLs[index];
                            urlLink.target = '_blank';
                            urlLink.rel = 'noopener noreferrer';
                            urlLink.textContent = 'View Evidence';
                            urlLink.className = 'premise-url';
                            urlLink.style.marginLeft = '10px';
                            urlLink.style.color = '#007bff';
                            urlLink.style.textDecoration = 'underline';
                            li.appendChild(urlLink);
                        }

                        // Add buttons
                        if (index < argumentObj.argumentLines.length - 1) {
                            const voteContainer = document.createElement('div');
                            voteContainer.className = 'premise-vote-container';
                            
                            const disagreeButton = document.createElement('button');
                            disagreeButton.textContent = 'Disagree with this premise';
                            disagreeButton.className = 'disagree-premise-button';
                            disagreeButton.dataset.argumentId = argumentObj.id;
                            disagreeButton.dataset.premiseIndex = index;
                            
                            // Always set initial onclick to check authentication
                            disagreeButton.onclick = function() {
                                const currentUser = firebase.auth().currentUser;
                                if (!currentUser) {
                                    alert('You must be logged in to disagree with a premise.');
                                    return;
                                }
                                updateDisagreement(this.dataset.argumentId, parseInt(this.dataset.premiseIndex));
                            };
                            
                            // If user is logged in, check their voting status
                            if (user) {
                                Promise.all([
                                    checkUserEndorsement(argumentObj.id),
                                    checkUserDisagreement(argumentObj.id, index)
                                ]).then(([hasEndorsed, hasDisagreed]) => {
                                    if (hasEndorsed) {
                                        // User endorsed, so disable disagree button
                                        disagreeButton.textContent = 'Already endorsed conclusion';
                                        disagreeButton.disabled = true;
                                        disagreeButton.style.backgroundColor = '#6c757d';
                                        disagreeButton.style.cursor = 'not-allowed';
                                        disagreeButton.onclick = null;
                                    } else if (hasDisagreed) {
                                        // User already disagreed with this premise
                                        disagreeButton.textContent = 'Remove Disagreement';
                                        disagreeButton.style.backgroundColor = '#6c757d';
                                        disagreeButton.onclick = function() {
                                            removeDisagreement(this.dataset.argumentId, parseInt(this.dataset.premiseIndex));
                                        };
                                    }
                                });
                            }
                            
                            voteContainer.appendChild(disagreeButton);
                            li.appendChild(voteContainer);
                        } else {
                            const endorseButton = document.createElement('button');
                            endorseButton.textContent = 'Endorse Conclusion';
                            endorseButton.className = 'endorse-conclusion-button';
                            endorseButton.dataset.argumentId = argumentObj.id;
                            
                            // Always set initial onclick to check authentication
                            endorseButton.onclick = function() {
                                const currentUser = firebase.auth().currentUser;
                                if (!currentUser) {
                                    alert('You must be logged in to endorse the conclusion.');
                                    return;
                                }
                                updateEndorsement(this.dataset.argumentId);
                            };
                            
                            // If user is logged in, check their voting status
                            if (user) {
                                Promise.all([
                                    checkUserEndorsement(argumentObj.id),
                                    checkUserAnyDisagreement(argumentObj.id)
                                ]).then(([hasEndorsed, hasDisagreed]) => {
                                    if (hasDisagreed) {
                                        // User disagreed with a premise, so disable endorse button
                                        endorseButton.textContent = 'Already disagreed with premise';
                                        endorseButton.disabled = true;
                                        endorseButton.style.backgroundColor = '#6c757d';
                                        endorseButton.style.cursor = 'not-allowed';
                                        endorseButton.onclick = null;
                                    } else if (hasEndorsed) {
                                        // User already endorsed
                                        endorseButton.textContent = 'Remove Endorsement';
                                        endorseButton.style.backgroundColor = '#6c757d';
                                        endorseButton.onclick = function() {
                                            removeEndorsement(this.dataset.argumentId);
                                        };
                                    }
                                });
                            }
                            
                            li.appendChild(document.createElement('br'));
                            li.appendChild(endorseButton);
                        }

                        ol.appendChild(li);
                    });

                    argumentContentDiv.appendChild(ol);

                    // Display endorsement stats
                    const endorsementStats = document.createElement('div');
                    endorsementStats.className = 'endorsement-stats';
                    endorsementStats.textContent = `Endorsements: ${argumentObj.endorsements || 0} | Disagreements: ${argumentObj.disagreements || 0} | Endorsement Percentage: ${argumentObj.endorsementPercentage ? argumentObj.endorsementPercentage.toFixed(2) : 0}%`;

                    argumentDiv.appendChild(argumentHeader);
                    argumentDiv.appendChild(claimElement);
                    argumentDiv.appendChild(argumentContentDiv);
                    argumentDiv.appendChild(endorsementStats);

                    argumentsList.appendChild(argumentDiv);
                });
            }).catch((error) => {
                console.error("Error getting documents: ", error);
            });
        }

        function updateEndorsement(argumentId) {
            const user = firebase.auth().currentUser;
            if (!user) {
                alert('You must be logged in to endorse.');
                return;
            }
            
            const argumentRef = db.collection('arguments').doc(argumentId);
            const endorsementRef = db.collection('arguments').doc(argumentId).collection('endorsements').doc(user.uid);
            const disagreementRef = db.collection('arguments').doc(argumentId).collection('disagreements').doc(user.uid);
            
            // Check if user already endorsed
            endorsementRef.get().then((doc) => {
                if (doc.exists) {
                    alert('You have already endorsed this argument.');
                    return;
                }
                
                // Use a transaction to update endorsement and remove any disagreement
                return db.runTransaction((transaction) => {
                    return transaction.get(argumentRef).then((doc) => {
                        if (!doc.exists) {
                            throw "Argument does not exist!";
                        }
                        
                        // Check if user has a disagreement to remove
                        return transaction.get(disagreementRef).then((disagreeDoc) => {
                            let newEndorsements = (doc.data().endorsements || 0) + 1;
                            let disagreements = doc.data().disagreements || 0;
                            
                            // If user had disagreed, remove that disagreement
                            if (disagreeDoc.exists) {
                                disagreements = Math.max(0, disagreements - 1);
                            }
                            
                            const totalVotes = newEndorsements + disagreements;
                            const endorsementPercentage = totalVotes > 0 ? (100 * newEndorsements) / totalVotes : 0;
                            
                            // Update the argument
                            transaction.update(argumentRef, {
                                endorsements: newEndorsements,
                                disagreements: disagreements,
                                endorsementPercentage: endorsementPercentage
                            });
                            
                            // Record that this user endorsed
                            transaction.set(endorsementRef, {
                                timestamp: firebase.firestore.FieldValue.serverTimestamp()
                            });
                            
                            // Remove any disagreement
                            if (disagreeDoc.exists) {
                                transaction.delete(disagreementRef);
                            }
                        });
                    });
                });
            }).then(() => {
                alert('You endorsed the conclusion.');
                displayArguments();
            }).catch((error) => {
                console.error("Transaction failed: ", error);
                if (error !== 'You have already endorsed this argument.') {
                    alert("Error endorsing: " + error);
                }
            });
        }

        function updateDisagreement(argumentId, premiseIndex) {
            const user = firebase.auth().currentUser;
            if (!user) {
                alert('You must be logged in to disagree.');
                return;
            }
            
            const argumentRef = db.collection('arguments').doc(argumentId);
            const disagreementRef = db.collection('arguments').doc(argumentId).collection('disagreements').doc(user.uid);
            const endorsementRef = db.collection('arguments').doc(argumentId).collection('endorsements').doc(user.uid);
            
            // Check if user already disagreed
            disagreementRef.get().then((doc) => {
                if (doc.exists) {
                    alert('You have already disagreed with this argument.');
                    return;
                }
                
                // Use a transaction to update disagreement and remove any endorsement
                return db.runTransaction((transaction) => {
                    return transaction.get(argumentRef).then((doc) => {
                        if (!doc.exists) {
                            throw "Argument does not exist!";
                        }
                        
                        // Check if user has an endorsement to remove
                        return transaction.get(endorsementRef).then((endorseDoc) => {
                            let newDisagreements = (doc.data().disagreements || 0) + 1;
                            let endorsements = doc.data().endorsements || 0;
                            
                            // If user had endorsed, remove that endorsement
                            if (endorseDoc.exists) {
                                endorsements = Math.max(0, endorsements - 1);
                            }
                            
                            const totalVotes = newDisagreements + endorsements;
                            const endorsementPercentage = totalVotes > 0 ? (100 * endorsements) / totalVotes : 0;
                            
                            // Update the argument
                            transaction.update(argumentRef, {
                                disagreements: newDisagreements,
                                endorsements: endorsements,
                                endorsementPercentage: endorsementPercentage
                            });
                            
                            // Record that this user disagreed and which premise
                            transaction.set(disagreementRef, {
                                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                                premiseIndex: premiseIndex
                            });
                            
                            // Remove any endorsement
                            if (endorseDoc.exists) {
                                transaction.delete(endorsementRef);
                            }
                        });
                    });
                });
            }).then(() => {
                alert('You disagreed with a premise.');
                displayArguments();
            }).catch((error) => {
                console.error("Transaction failed: ", error);
                if (error !== 'You have already disagreed with this argument.') {
                    alert("Error disagreeing: " + error);
                }
            });
        }
        
        function checkUserEndorsement(argumentId) {
            const user = firebase.auth().currentUser;
            if (!user) return Promise.resolve(false);
            
            return db.collection('arguments').doc(argumentId).collection('endorsements').doc(user.uid)
                .get()
                .then(doc => doc.exists);
        }
        
        function checkUserDisagreement(argumentId, premiseIndex) {
            const user = firebase.auth().currentUser;
            if (!user) return Promise.resolve(false);
            
            return db.collection('arguments').doc(argumentId).collection('disagreements').doc(user.uid)
                .get()
                .then(doc => doc.exists && doc.data().premiseIndex === premiseIndex);
        }
        
        function checkUserAnyDisagreement(argumentId) {
            const user = firebase.auth().currentUser;
            if (!user) return Promise.resolve(false);
            
            return db.collection('arguments').doc(argumentId).collection('disagreements').doc(user.uid)
                .get()
                .then(doc => doc.exists);
        }
        
        function removeEndorsement(argumentId) {
            const user = firebase.auth().currentUser;
            if (!user) {
                alert('You must be logged in.');
                return;
            }
            
            const argumentRef = db.collection('arguments').doc(argumentId);
            const endorsementRef = db.collection('arguments').doc(argumentId).collection('endorsements').doc(user.uid);
            
            db.runTransaction((transaction) => {
                return transaction.get(argumentRef).then((doc) => {
                    if (!doc.exists) {
                        throw "Argument does not exist!";
                    }
                    
                    const currentEndorsements = Math.max(0, (doc.data().endorsements || 0) - 1);
                    const disagreements = doc.data().disagreements || 0;
                    const totalVotes = currentEndorsements + disagreements;
                    const endorsementPercentage = totalVotes > 0 ? (100 * currentEndorsements) / totalVotes : 0;
                    
                    // Update the argument
                    transaction.update(argumentRef, {
                        endorsements: currentEndorsements,
                        endorsementPercentage: endorsementPercentage
                    });
                    
                    // Remove the endorsement record
                    transaction.delete(endorsementRef);
                });
            }).then(() => {
                alert('Endorsement removed.');
                displayArguments();
            }).catch((error) => {
                console.error("Transaction failed: ", error);
                alert("Error removing endorsement: " + error);
            });
        }
        
        function removeDisagreement(argumentId, premiseIndex) {
            const user = firebase.auth().currentUser;
            if (!user) {
                alert('You must be logged in.');
                return;
            }
            
            const argumentRef = db.collection('arguments').doc(argumentId);
            const disagreementRef = db.collection('arguments').doc(argumentId).collection('disagreements').doc(user.uid);
            
            db.runTransaction((transaction) => {
                return transaction.get(argumentRef).then((doc) => {
                    if (!doc.exists) {
                        throw "Argument does not exist!";
                    }
                    
                    const currentDisagreements = Math.max(0, (doc.data().disagreements || 0) - 1);
                    const endorsements = doc.data().endorsements || 0;
                    const totalVotes = currentDisagreements + endorsements;
                    const endorsementPercentage = totalVotes > 0 ? (100 * endorsements) / totalVotes : 0;
                    
                    // Update the argument
                    transaction.update(argumentRef, {
                        disagreements: currentDisagreements,
                        endorsementPercentage: endorsementPercentage
                    });
                    
                    // Remove the disagreement record
                    transaction.delete(disagreementRef);
                });
            }).then(() => {
                alert('Disagreement removed.');
                displayArguments();
            }).catch((error) => {
                console.error("Transaction failed: ", error);
                alert("Error removing disagreement: " + error);
            });
        }
        
        function populateFilterClaims() {
            const filterClaimSelect = document.getElementById('filterClaimSelect');
            if (!filterClaimSelect) return;
            
            filterClaimSelect.innerHTML = '<option value="">-- All Claims --</option>';
            const claimsSet = new Set();

            // Collect all claims
            for (const category in claimsByCategory) {
                for (const subcategory in claimsByCategory[category]) {
                    claimsByCategory[category][subcategory].forEach(claim => {
                        claimsSet.add(claim.text);
                    });
                }
            }

            // Add claims to the select element
            claimsSet.forEach(claimText => {
                const option = document.createElement('option');
                option.value = claimText;
                option.textContent = claimText;
                filterClaimSelect.appendChild(option);
            });
        }

        // Stubs for old functions
        function displayArgumentForms(stance) { console.log("Old displayArgumentForms called - Templates disabled."); }
        function generatePlaceholderInputs(form) { console.log("Old generatePlaceholderInputs called - Templates disabled."); }
        function createVariableRectangles(text, placeholderValues, isForm = false) { return text; }
        function constructArgument(form, placeholderValues) { return []; }
        function collectPremiseURLs(form) { return {}; }
        function validateArgument(form, placeholderValues) { return true; } 

        // Wait for DOM to be ready
        function initializeApp() {
            console.log("Script 2: initializeApp called");
            
            // Populate category dropdown
            const categorySelect = document.getElementById('categorySelect');
            if (categorySelect) {
                console.log("Script 2: Found categorySelect element");
                for (const category in claimsByCategory) {
                    const option = document.createElement('option');
                    option.value = category;
                    option.textContent = category;
                    categorySelect.appendChild(option);
                }
                console.log("Script 2: Categories populated");
                
                // Set up category change listener
                categorySelect.addEventListener('change', function() {
                    const subcategorySelect = document.getElementById('subcategorySelect');
                    const claimSelect = document.getElementById('claimSelect');
                    
                    subcategorySelect.innerHTML = '<option value="">-- Choose a Subcategory --</option>';
                    claimSelect.innerHTML = '<option value="">-- Choose a Claim --</option>';
                    
                    const selectedCategory = this.value;
                    if (selectedCategory && claimsByCategory[selectedCategory]) {
                        for (const subcategory in claimsByCategory[selectedCategory]) {
                            const option = document.createElement('option');
                            option.value = subcategory;
                            option.textContent = subcategory;
                            subcategorySelect.appendChild(option);
                        }
                    }
                    
                    // Reset subsequent selections
                    const stanceSelect = document.getElementById('stanceSelect');
                    if(stanceSelect) stanceSelect.value = "";
                    document.getElementById('dynamicArgumentBuilder').style.display = 'none';
                    const statementDefArea = document.getElementById('statementDefinitionArea');
                    if (statementDefArea) statementDefArea.style.display = 'none';
                    const validityResultDiv = document.getElementById('validityResult');
                    if(validityResultDiv) validityResultDiv.textContent = '';
                });
            }
            
            // Set up subcategory change listener
            const subcategorySelect = document.getElementById('subcategorySelect');
            if (subcategorySelect) {
                subcategorySelect.addEventListener('change', function() {
                    const categorySelect = document.getElementById('categorySelect');
                    const claimSelect = document.getElementById('claimSelect');
                    
                    claimSelect.innerHTML = '<option value="">-- Choose a Claim --</option>';
                    
                    const selectedCategory = categorySelect.value;
                    const selectedSubcategory = this.value;
                    
                    if (selectedCategory && selectedSubcategory && 
                        claimsByCategory[selectedCategory] && 
                        claimsByCategory[selectedCategory][selectedSubcategory]) {
                        
                        claimsByCategory[selectedCategory][selectedSubcategory].forEach(claim => {
                            const option = document.createElement('option');
                            option.value = claim.value;
                            option.textContent = claim.text;
                            claimSelect.appendChild(option);
                        });
                    }
                    
                    populateFilterClaims();
                    
                    // Reset subsequent selections
                    const stanceSelect = document.getElementById('stanceSelect');
                    if(stanceSelect) stanceSelect.value = "";
                    document.getElementById('dynamicArgumentBuilder').style.display = 'none';
                    const statementDefArea = document.getElementById('statementDefinitionArea');
                    if (statementDefArea) statementDefArea.style.display = 'none';
                    const validityResultDiv = document.getElementById('validityResult');
                    if(validityResultDiv) validityResultDiv.textContent = '';
                });
            }
            
            // Set up claim change listener
            const claimSelect = document.getElementById('claimSelect');
            if (claimSelect) {
                claimSelect.addEventListener('change', function() {
                    const stanceSelect = document.getElementById('stanceSelect');
                    if(stanceSelect) stanceSelect.value = ""; 
                    document.getElementById('dynamicArgumentBuilder').style.display = 'none';
                    const statementDefArea = document.getElementById('statementDefinitionArea');
                    if (statementDefArea) statementDefArea.style.display = 'none';
                    const validityResultDiv = document.getElementById('validityResult');
                    if(validityResultDiv) validityResultDiv.textContent = '';
                });
            }
            
            // Set up button
            const setClaimAndBuildButton = document.getElementById('setClaimAndBuildButton');
            if (setClaimAndBuildButton) {
                setClaimAndBuildButton.addEventListener('click', initializeAndShowDynamicBuilder);
            }
            
            // Set up ranking
            const rankingSelect = document.getElementById('rankingSelect');
            if (rankingSelect) {
                rankingSelect.addEventListener('change', displayArguments);
            }
            
            // Initial calls
            populateFilterClaims();
            displayArguments();
        }

        // Auth state listener
        firebase.auth().onAuthStateChanged(function(user) {
            const authContainer = document.getElementById('authContainer');
            const logoutButton = document.getElementById('logoutButton');
            const claimSetupForm = document.getElementById('claimSetupForm');
            const dynamicBuilderSection = document.getElementById('dynamicArgumentBuilder');
            
            if (user) {
                if (authContainer) authContainer.style.display = 'none';
                if (logoutButton) logoutButton.style.display = 'block';
            } else {
                if (authContainer) authContainer.style.display = 'block';
                if (logoutButton) logoutButton.style.display = 'none';
                if(dynamicBuilderSection) dynamicBuilderSection.style.display = 'none';
            }
            
            // Always show claim setup form
            if (claimSetupForm) claimSetupForm.style.display = 'block';
        });

        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeApp);
        } else {
            initializeApp();
        }
        
        console.log("Script 2: Main script completed");
        
        // Mobile-specific enhancements
        function initializeMobileFeatures() {
            // Detect if mobile device
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || window.innerWidth <= 768;
            
            if (isMobile) {
                // Add touch class to body
                document.body.classList.add('touch-device');
                
                // Initialize touch gestures
                initializeTouchGestures();
                
                // Initialize pull to refresh
                initializePullToRefresh();
                
                // Improve form interactions
                improveMobileForms();
                
                // Add mobile-specific event handlers
                addMobileHandlers();
            }
        }
        
        function initializeTouchGestures() {
            let touchStartX = 0;
            let touchStartY = 0;
            
            // Add swipe detection to premise slots
            document.addEventListener('touchstart', function(e) {
                const premiseSlot = e.target.closest('.premise-slot');
                if (premiseSlot) {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                }
            });
            
            document.addEventListener('touchend', function(e) {
                const premiseSlot = e.target.closest('.premise-slot');
                if (premiseSlot) {
                    const touchEndX = e.changedTouches[0].clientX;
                    const touchEndY = e.changedTouches[0].clientY;
                    const diffX = touchStartX - touchEndX;
                    const diffY = Math.abs(touchStartY - touchEndY);
                    
                    // Only register horizontal swipes
                    if (diffX > 50 && diffY < 100) {
                        premiseSlot.classList.add('swiped');
                        setTimeout(() => {
                            premiseSlot.classList.remove('swiped');
                        }, 3000);
                    }
                }
            });
        }
        
        function initializePullToRefresh() {
            let startY = 0;
            let isPulling = false;
            
            document.addEventListener('touchstart', function(e) {
                if (window.scrollY === 0) {
                    startY = e.touches[0].clientY;
                    isPulling = true;
                }
            });
            
            document.addEventListener('touchmove', function(e) {
                if (!isPulling) return;
                
                const currentY = e.touches[0].clientY;
                const diff = currentY - startY;
                
                if (diff > 0 && diff < 150) {
                    const pullToRefresh = document.querySelector('.pull-to-refresh');
                    pullToRefresh.style.transform = `translateY(${diff}px)`;
                }
            });
            
            document.addEventListener('touchend', function(e) {
                if (!isPulling) return;
                
                const pullToRefresh = document.querySelector('.pull-to-refresh');
                const currentY = e.changedTouches[0].clientY;
                const diff = currentY - startY;
                
                if (diff > 100) {
                    // Trigger refresh
                    pullToRefresh.innerHTML = '<i class="fas fa-sync fa-spin"></i> <span style="margin-left: 10px;">Refreshing...</span>';
                    location.reload();
                } else {
                    pullToRefresh.style.transform = 'translateY(0)';
                }
                
                isPulling = false;
            });
        }
        
        function improveMobileForms() {
            // Add touch-friendly class to all interactive elements
            const interactiveElements = document.querySelectorAll('button, select, input, .palette-item, .drop-zone');
            interactiveElements.forEach(el => {
                el.classList.add('touchable');
            });
            
            // Improve select elements on iOS
            const selects = document.querySelectorAll('select');
            selects.forEach(select => {
                select.addEventListener('focus', function() {
                    this.size = Math.min(this.options.length, 5);
                });
                select.addEventListener('blur', function() {
                    this.size = 0;
                });
                select.addEventListener('change', function() {
                    this.size = 0;
                    this.blur();
                });
            });
        }
        
        function addMobileHandlers() {
            // Long press to edit propositions
            let pressTimer;
            document.addEventListener('touchstart', function(e) {
                const proposition = e.target.closest('.palette-item.proposition');
                if (proposition && !proposition.classList.contains('prop-k')) {
                    pressTimer = setTimeout(() => {
                        const letter = proposition.textContent.trim().charAt(0);
                        if (window.editPropositionText) {
                            navigator.vibrate && navigator.vibrate(50);
                            window.editPropositionText(letter);
                        }
                    }, 500);
                }
            });
            
            document.addEventListener('touchend', function() {
                clearTimeout(pressTimer);
            });
            
            // Double tap to validate
            let lastTap = 0;
            document.addEventListener('touchend', function(e) {
                const argumentBuilder = e.target.closest('#dynamicArgumentBuilder');
                if (argumentBuilder) {
                    const currentTime = new Date().getTime();
                    const tapGap = currentTime - lastTap;
                    if (tapGap < 300 && tapGap > 0) {
                        document.getElementById('checkFormValidityButton').click();
                    }
                    lastTap = currentTime;
                }
            });
        }
        
        // Mobile utility functions
        function scrollToTop() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }
        
        function showMobileMenu() {
            // Create a simple mobile menu
            const menuItems = [
                { text: 'My Arguments', action: () => console.log('Show user arguments') },
                { text: 'Settings', action: () => console.log('Show settings') },
                { text: 'Help', action: () => showMobileAlert('Swipe left on premises to see options. Long press to edit.', 'info') },
                { text: 'Logout', action: () => document.getElementById('logoutButton').click() }
            ];
            
            // You could implement a proper menu modal here
            showMobileAlert('Menu coming soon!', 'info');
        }
        
        function showMobileAlert(message, type = 'error') {
            const alertEl = document.getElementById('mobileAlert');
            alertEl.textContent = message;
            alertEl.className = `mobile-alert ${type} show`;
            
            setTimeout(() => {
                alertEl.classList.remove('show');
            }, 3000);
        }
        
        // Replace default alerts with mobile-friendly ones on mobile devices
        if (window.innerWidth <= 768) {
            const originalAlert = window.alert;
            window.alert = function(message) {
                showMobileAlert(message, 'info');
            };
        }
        
        // Initialize mobile features when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeMobileFeatures);
        } else {
            initializeMobileFeatures();
        }
        
        // PWA Installation
        let deferredPrompt;
        
        // Register Service Worker
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => {
                        console.log('ServiceWorker registration successful');
                        
                        // Check for updates periodically
                        setInterval(() => {
                            registration.update();
                        }, 60000); // Check every minute
                    })
                    .catch(err => {
                        console.log('ServiceWorker registration failed: ', err);
                    });
            });
        }
        
        // Listen for beforeinstallprompt
        window.addEventListener('beforeinstallprompt', (e) => {
            // Prevent Chrome 67 and earlier from automatically showing the prompt
            e.preventDefault();
            // Stash the event so it can be triggered later
            deferredPrompt = e;
            // Show install button
            showInstallPromotion();
        });
        
        function showInstallPromotion() {
            // Create install banner
            const installBanner = document.createElement('div');
            installBanner.id = 'installBanner';
            installBanner.style.cssText = `
                position: fixed;
                bottom: 80px;
                left: 20px;
                right: 20px;
                background: #007bff;
                color: white;
                padding: 15px;
                border-radius: 10px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                display: flex;
                align-items: center;
                justify-content: space-between;
                z-index: 1000;
                transform: translateY(200px);
                transition: transform 0.3s ease;
            `;
            
            installBanner.innerHTML = `
                <div>
                    <strong>Install Crux</strong>
                    <p style="margin: 5px 0 0 0; font-size: 14px;">Add to your home screen for the best experience</p>
                </div>
                <button id="installBtn" style="
                    background: white;
                    color: #007bff;
                    border: none;
                    padding: 10px 20px;
                    border-radius: 6px;
                    font-weight: bold;
                    cursor: pointer;
                ">Install</button>
            `;
            
            document.body.appendChild(installBanner);
            
            // Animate in
            setTimeout(() => {
                installBanner.style.transform = 'translateY(0)';
            }, 100);
            
            // Install button click
            document.getElementById('installBtn').addEventListener('click', async () => {
                if (deferredPrompt) {
                    deferredPrompt.prompt();
                    const { outcome } = await deferredPrompt.userChoice;
                    console.log(`User response to the install prompt: ${outcome}`);
                    deferredPrompt = null;
                    installBanner.remove();
                }
            });
            
            // Close button
            const closeBtn = document.createElement('button');
            closeBtn.innerHTML = '';
            closeBtn.style.cssText = `
                position: absolute;
                top: 5px;
                right: 5px;
                background: none;
                border: none;
                color: white;
                font-size: 24px;
                cursor: pointer;
                padding: 0;
                width: 30px;
                height: 30px;
            `;
            closeBtn.onclick = () => {
                installBanner.style.transform = 'translateY(200px)';
                setTimeout(() => installBanner.remove(), 300);
            };
            installBanner.appendChild(closeBtn);
        }
        
        // Detect if app is installed
        window.addEventListener('appinstalled', () => {
            console.log('Crux was installed');
            // Hide install promotion
            const banner = document.getElementById('installBanner');
            if (banner) banner.remove();
        });
        
        // iOS install instructions
        function showiOSInstallInstructions() {
            if (window.navigator.standalone) {
                return; // Already installed
            }
            
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
            
            if (isIOS && !localStorage.getItem('iosInstallDismissed')) {
                const instructions = document.createElement('div');
                instructions.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    left: 20px;
                    right: 20px;
                    background: white;
                    padding: 20px;
                    border-radius: 12px;
                    box-shadow: 0 4px 20px rgba(0,0,0,0.1);
                    z-index: 1000;
                `;
                
                instructions.innerHTML = `
                    <h3 style="margin: 0 0 10px 0;">Install Crux</h3>
                    <p style="margin: 0 0 15px 0; font-size: 14px;">
                        Tap <img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTEwIDAuNVYxMy41TTEwIDEzLjVMNiA5LjVNMTAgMTMuNUwxNCA5LjUiIHN0cm9rZT0iIzAwN0FGRiIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPHBhdGggZD0iTTEgMTRIMTlWMTlIMVYxNFoiIHN0cm9rZT0iIzAwN0FGRiIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPC9zdmc+" style="width: 20px; height: 20px; vertical-align: middle;"> 
                        then "Add to Home Screen"
                    </p>
                    <button onclick="this.parentElement.remove(); localStorage.setItem('iosInstallDismissed', 'true');" style="
                        background: #007bff;
                        color: white;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 6px;
                        width: 100%;
                        font-weight: bold;
                    ">Got it</button>
                `;
                
                document.body.appendChild(instructions);
            }
        }
        
        // Show iOS instructions after a delay
        setTimeout(showiOSInstallInstructions, 3000);
    </script>
</body>
</html>